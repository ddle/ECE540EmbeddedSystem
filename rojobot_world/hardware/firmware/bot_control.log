KCPSM6 Assembler log file for program 'C:\ece540_final\rojobot_world\hardware\firmware\bot_control.psm'.
Generated by KCPSM6 version v2.00
Ken Chapman - Xilinx Ltd - 30th April 2012

Assembly datestamp: 15 Nov 2012
Assembly timestamp: 19:44:57

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels


Last occupied address: 3FF hex
Nominal program memory size: 1K    address(9:0)


Assembly listing

 Addr Code                      Instruction

 000                            ; -----------------------------------------------------------------
 000                            ; bot_control.psm - rojobot control program for ECE 540 project 2, Winter 2012
 000                            ;  modified from: proj2demo.psm - Demo program for Rojobot "world" emulator
 000                            ;     Author: Roy Kravitz
 000                            ;                   Version: 1.2
 000                            ;                   Date:  24-Oct-12
 000                            ;
 000                            ; Description:
 000                            ; ============
 000                            ; This program implements a line-following algorithm to guide a RojoBot 3.1
 000                            ; safely through a virtual RojoBot world.
 000                            ;
 000                            ; INTERFACE
 000                            ;  Switch 0: "Display mode"
 000                            ;    When switch[0] is 'off' the program displays the location of the
 000                            ;    Rojobot in its "world" on the 4 digits of the 7-segment display.
 000                            ;     Digit 3 and digit 2 display the x-coordinate in Hex.
 000                            ;     Digit 1 and digit 0 display the y-coordinate in Hex.
 000                            ;
 000                            ;     When switch[0] is 'on' the program uses the 4 7-segment display
 000                            ;    digits as follows:
 000                            ;     digit[3] Indicates the Rojobot movement (Stopped, Forward,
 000                            ;       Reverse, etc.) in Hex.
 000                            ;    digits[2:0] Indicates the Rojobot's heading in degrees.
 000                            ;
 000                            ; Switch 1: "Toggle movement"
 000                            ;    When switch[1] is off, the Rojobot will "pause" and not make any
 000                            ;    movements until switch[1] is turned on again.  Interrupts
 000                            ;    continue to run, and all other interface still function normally
 000                            ;    When switch[1] is turned on again, Rojobot will resume whatever
 000                            ;    action was underway when the switch was turned off.
 000                            ;
 000                            ; Switch 2: Unused
 000                            ;
 000                            ; Switch[7-3] "Wheel Threshold"
 000                            ;    This 5-bit binary value sets the wheel movement
 000                            ;    threshold for both the left and right motor.  Writing a large
 000                            ;    value slows the BOT down.  Writing a small value speeds the BOT
 000                            ;    up.  Values lower than 4 are treated as equal to 4.
 000                            ; OUTPUT
 000                            ;
 000                            ;  LEDs:  The sensors are displayed on the LEDs in both display modes.
 000                            ;
 000                            ;  Decimal Pt: During normal operation, the decimal points chase left-to-right
 000                            ;    Upon hitting an obstacle, decimal point 0 flashes each interrupt
 000                            ; -----------------------------------------------------------------
 000                            ; ============================================
 000                            ; === Register Names                       ===
 000                            ; === s6 - s0 registers are not dedicated  ===
 000                            ; === and keep their default names         ===
 000                            ; ============================================
 000                            NAMEREG sF, LocX                 ; rojobot location - x coordinate
 000                            NAMEREG sE, LocY                 ; rojobot location - y coordinate
 000                            NAMEREG sD, Sensor               ; rojobot sensor values
 000                            NAMEREG sC, Botinf               ; rojobot movement and orientation values
 000                            NAMEREG sB, MVst                 ; state variable for movement indicator
 000                            NAMEREG sA, Dig3                 ; 7-segment display digit 3
 000                            NAMEREG s9, Dig2                 ; 7-segment display digit 2
 000                            NAMEREG s8, Dig1                 ; 7-segment display digit 1
 000                            NAMEREG s7, Dig0                 ; 7-segment display digit 0
 000                            ; ======================
 000                            ; === Port Addresses ===
 000                            ; ======================
 000                            ;  Port Addresses
 000                            CONSTANT PA_PBTNS, 00            ; (i) pushbuttons
 000                            CONSTANT PA_SLSWTCH, 01          ; (i) slide switches
 000                            CONSTANT PA_LEDS, 02             ; (o) LEDs
 000                            CONSTANT PA_DIG3, 03             ; (o) digit 3 PA address
 000                            CONSTANT PA_DIG2, 04             ; (o) digit 2 PA address
 000                            CONSTANT PA_DIG1, 05             ; (o) digit 1 PA address
 000                            CONSTANT PA_DIG0, 06             ; (o) digit 0 PA address
 000                            CONSTANT PA_DP, 07               ; (o) decimal points PA address
 000                            CONSTANT PA_RSVD, 08             ; (o) *RESERVED*
 000                            ; rojobot interface registers
 000                            CONSTANT PA_MOTCTL_IN, 09        ; (o) Rojobot motor control output
 000                            CONSTANT PA_LOCX, 0A             ; (i) X coordinate of rojobot location
 000                            CONSTANT PA_LOCY, 0B             ; (i))Y coordinate of rojobot location
 000                            CONSTANT PA_BOTINFO, 0C          ; (i) Rojobot info register
 000                            CONSTANT PA_SENSORS, 0D          ; (i) Sensor register
 000                            CONSTANT PA_LMDIST, 0E           ; (i) Rojobot left motor distance register
 000                            CONSTANT PA_RMDIST, 0F           ; (i) Rojobot right motor distance register
 000                            ; =====================================
 000                            ; === Register bit mappings (masks) ===
 000                            ; =====================================
 000                            ;  bit masks for pushbuttons and switches for seven segment emulator
 000                            CONSTANT MSK_ALLBTNS, 1F         ; Buttons are in bits[5:0]
 000                            CONSTANT MSK_PBTNS, 0F           ; Mask for 4 buttons to display on LED
 000                            CONSTANT MSK_BTN_CENTER, 10      ; Pushbutton Center is bit 4
 000                            CONSTANT MSK_BTN_LEFT, 08        ; Pushbutton Left is bit 3
 000                            CONSTANT MSK_BTN_UP, 04          ; Pushbutton Up is bit 2
 000                            CONSTANT MSK_BTN_RIGHT, 02       ; Pushbutton Right is bit 1
 000                            CONSTANT MSK_BTN_DOWN, 01        ; Pusbhbutton Down is bit 0
 000                            CONSTANT MSK_ALLSW, FF           ; Slide switches are in bits[7:0]
 000                            CONSTANT MSK_SW7, 80             ; Slide switch 7 is bit 7
 000                            CONSTANT MSK_SW6, 40             ; Slide switch 6 is bit 6
 000                            CONSTANT MSK_SW5, 20             ; Slide switch 5 is bit 5
 000                            CONSTANT MSK_SW4, 10             ; Slide switch 4 is bit 4
 000                            CONSTANT MSK_SW3, 08             ; Slide switch 3 is bit 3
 000                            CONSTANT MSK_SW2, 04             ; Slide switch 2 is bit 2
 000                            CONSTANT MSK_SW1, 02             ; Slide switch 1 is bit 1
 000                            CONSTANT MSK_SW0, 01             ; Slide switch 0 is bit 0
 000                            ; bit mask for LEDs
 000                            CONSTANT MSK_LEDS, FF            ; There are 8 LEDs on the Nexys 3
 000                            ; bit mask for display character codes and decimal points
 000                            CONSTANT MSK_CCODE, 1F           ; Character codes are in lower 5 bits
 000                            CONSTANT MSK_DECPTS, 0F          ; Decimal points are in bits 3 to 0
 000                            CONSTANT MSK_HEXDIGIT, 0F        ; Hex digits only take 4 bits
 000                            ; nibble masks
 000                            CONSTANT MSKLOWNIB, 0F           ; Mask out high nibble of byte
 000                            CONSTANT MSKHIGHNIB, F0          ; Mask out low nibble of byte
 000                            CONSTANT INVLOWNIB, 0F           ; Invert low nibble of byte
 000                            ; sensor masks
 000                            CONSTANT MSK_BL, 07              ; mask out all but BlkL sensors [2:0]
 000                            CONSTANT MSK_PS, 18              ; mask out all but PROXL[4] and PROXR[3]
 000                            ; Botinfo masks
 000                            CONSTANT MSKORIENT, 07           ; mask out all but orientation
 000                            ; motor control
 000                            CONSTANT MOVE_NOT, 00            ; word to stop all motion
 000                            CONSTANT MOVE_F, 33              ; word to move forward
 000                            CONSTANT MOVE_R, 66              ; word to move reverse
 000                            CONSTANT TURN_R, 30              ; word to turn left
 000                            CONSTANT TURN_L, 03              ; word to turn
 000                            CONSTANT MOVE_FF, FF             ;
 000                            ; line following algorithm flags: all of following refer to SP_LINEFLAGS[6:0]
 000                            CONSTANT MODE_NORMAL, 01
 000                            CONSTANT MODE_NOLINEREVERSE, 02
 000                            CONSTANT MODE_TURN135L, 04
 000                            CONSTANT MODE_BEGINTEST, 08
 000                            CONSTANT MODE_FORWARDTEST, 10
 000                            CONSTANT MODE_FAILREVERSE, 20
 000                            CONSTANT MODE_TURN45R, 40
 000                            ; =============================
 000                            ; === Useful Data Constants ===
 000                            ; =============================
 000                            ;  Constants for True and False and Null
 000                            CONSTANT FALSE, 00
 000                            CONSTANT TRUE, 01
 000                            CONSTANT NULL, 00
 000                            ; Character code table for special characters
 000                            ; Decimal digits 0 to 15 display '0'to 'F'
 000                            CONSTANT CC_BASE, 10             ; Base value for special characters
 000                            CONSTANT CC_SEGBASE, 10          ; Base value for segment display characters
 000                            ;     abcdefg
 000                            CONSTANT CC_SEGA, 10             ; Segment A  [1000000]
 000                            CONSTANT CC_SEGB, 11             ; Segment B  [0100000]
 000                            CONSTANT CC_SEGC, 12             ; Segment C  [0010000]
 000                            CONSTANT CC_SEGD, 13             ; Segment D  [0001000]
 000                            CONSTANT CC_SEGE, 14             ; Segment E  [0000100]
 000                            CONSTANT CC_SEGF, 15             ; Segment F  [0000010]
 000                            CONSTANT CC_SEGG, 16             ; Segment G  [0000001]
 000                            CONSTANT CC_DOT, 17              ; Dot (period)
 000                            CONSTANT CC_UCH, 18              ; Upper Case H
 000                            CONSTANT CC_UCL, 19              ; Upper Case L
 000                            CONSTANT CC_UCR, 1A              ; Upper Case R
 000                            CONSTANT CC_LCL, 1B              ; Lower Case L
 000                            CONSTANT CC_LCR, 1C              ; Lower Case R
 000                            CONSTANT CC_SPACE1, 1D           ; Space (blank)
 000                            CONSTANT CC_SPACE2, 1E           ; Space (blank)
 000                            CONSTANT CC_SPACE, 1F            ; Space (blank)
 000                            ; ======================
 000                            ; === BotInfo values ===
 000                            ; ======================
 000                            CONSTANT OR_N, 00                ; Orientation is North
 000                            CONSTANT OR_NE, 01               ; Orientation is Northeast
 000                            CONSTANT OR_E, 02                ; Orientation is East
 000                            CONSTANT OR_SE, 03               ; Orientation is Southeast
 000                            CONSTANT OR_S, 04                ; Orientation is South
 000                            CONSTANT OR_SW, 05               ; Orientation is Southwest
 000                            CONSTANT OR_W, 06                ; Orientation is West
 000                            CONSTANT OR_NW, 07               ; Orientation is Northwest
 000                            CONSTANT MV_STOP, 00             ; Movement is stopped
 000                            CONSTANT MV_FWD, 04              ; Movement is forward
 000                            CONSTANT MV_REV, 08              ; Movement is reverse
 000                            CONSTANT MV_SLT, 0C              ; Movement is slow left turn
 000                            CONSTANT MV_FLT, 0D              ; Movement is fast left turn
 000                            CONSTANT MV_SRT, 0E              ; Movement is slow right turn
 000                            CONSTANT MV_FRT, 0F              ; Movement is fast right turn
 000                            ; =================================
 000                            ; === Scratch Pad RAM Variables ===
 000                            ; =================================
 000                            ; Movement display lookup table.  Converts movement from BotInfo register to
 000                            ; the character code to display.  Not very dense but we have the room in the
 000                            ; SP RAM and it saves building a switch statement into the code.
 000                            CONSTANT SP_MVMTBASE, 10         ; table is based at 0x10
 000                            CONSTANT SP_MVMT0, 18            ; Stopped - display upper case H
 000                            CONSTANT SP_MVMT1, 17            ; Reserved - display dot to indicate error
 000                            CONSTANT SP_MVMT2, 17            ; Reserved - display dot to indicate error
 000                            CONSTANT SP_MVMT3, 17            ; Reserved - display dot to indicate error
 000                            CONSTANT SP_MVMT4, 0F            ; Forward - display upper case F
 000                            CONSTANT SP_MVMT5, 17            ; Reserved - display dot to indicate error
 000                            CONSTANT SP_MVMT6, 17            ; Reserved - display dot to indicate error
 000                            CONSTANT SP_MVMT7, 17            ; Reserved - display dot to indicate error
 000                            CONSTANT SP_MVMT8, 0B            ; Reverse (Backward) - display lower case B
 000                            CONSTANT SP_MVMT9, 17            ; Reserved - display dot to indicate error
 000                            CONSTANT SP_MVMTA, 17            ; Reserved - display dot to indicate error
 000                            CONSTANT SP_MVMTB, 17            ; Reserved - display dot to indicate error
 000                            CONSTANT SP_MVMTC, 19            ; Slow left turn - display upper case L
 000                            CONSTANT SP_MVMTD, 1B            ; Fast left turn - display lower case L
 000                            CONSTANT SP_MVMTE, 1A            ; Slow right turn - display upper case R
 000                            CONSTANT SP_MVMTF, 1C            ; Fast right turn - display lower case R
 000                            ; ==============================
 000                            ; === Storage for old values ===
 000                            ; ==============================
 000                            CONSTANT SP_SEM, 20              ; Semaphore between isr and main loop
 000                            CONSTANT SP_TEMP1, 21            ; Temp storage.  Used by ISR
 000                            CONSTANT SP_TEMP2, 22            ;
 000                            CONSTANT SP_LMDIST, 23           ; Storage for left/right motor counters
 000                            CONSTANT SP_RMDIST, 24           ;
 000                            CONSTANT SP_OLDMVMT, 25          ; Old movement value
 000                            CONSTANT SP_OLDHDG, 26           ; Old heading value
 000                            CONSTANT SP_OLDDP, 27            ; Old decimal points
 000                            CONSTANT SP_ORIG_X, 04           ; temporary location storage
 000                            CONSTANT SP_ORIG_Y, 05           ; temporary location storage
 000                            CONSTANT SP_ORIG_O, 06           ; temporary orientation storage
 000                            CONSTANT SP_PREV_OR, 07          ; stores desired dir for 135 degree turn
 000                            CONSTANT SP_TURN_COUNT, 08       ; used during 135 degree left turn
 000                            CONSTANT MODE, 0A                ; state of rojobot, see line following flags
 000                            CONSTANT TEMP_COUNT, 09          ; used during forward_test mode
 000                            ; ===============
 000                            ; === main()  ===
 000                            ; ===============
 000                            ADDRESS 000
 000  20029                     CALL 029[init_mvmttbl]           ; initialize movement to character code lookup table
 001  01100                     LOAD s1, 00                      ; clear the semaphore
 002  2F120                     STORE s1, 20[SP_SEM]             ;
 003  01101                     LOAD s1, 01                      ; turn off all of the decimal points
 004  2017C                     CALL 17C[SS_wrdpts]              ; toggles decimal points according to s1[3:0]
 005  2F127                     STORE s1, 27[SP_OLDDP]           ; and save the value
 006  01101                     LOAD s1, 01[MODE_NORMAL]         ; always initialize to normal
 007  2F10A                     STORE s1, 0A[MODE]               ;
 008  28001                     ENABLE INTERRUPT                 ; get the ball rolling
 009                            ; ==================
 009                            ; === Main  Loop ===
 009                            ; ==================
 009                            ; while(1) {  // main loop is an infinite loop
 009  0B620            main_L0: FETCH s6, 20[SP_SEM]             ; while (SP_SEMA == 0)  {}   // loop until isr updates rojobot registers
 00A  1D600                     COMPARE s6, 00                   ;
 00B  32009                     JUMP Z, 009[main_L0]             ;
 00C                            ;
 00C  2016D                     CALL 16D[DEB_rdsw]               ; s0 = switches
 00D  0D001                     TEST s0, 01[MSK_SW0]             ; if (sw[0] == 0)   // display the Rojobot location
 00E  36011                     JUMP NZ, 011[main_L1]            ; -- Z = 0 says switch is 'on'
 00F  200B0                     CALL 0B0[next_loc]               ; Dig[3:2] = LocX; Dig[1:0] = LocY
 010  22013                     JUMP 013[main_L2]                ;
 011                            ; else {  // display movement and heading
 011  20075            main_L1: CALL 075[next_mvmt]              ;  Dig[3] = next movement
 012  2007D                     CALL 07D[next_hdg]               ;  Dig[2:0] = next heading
 013                            ;  }
 013  2001C            main_L2: CALL 01C[wr_alldigits]           ; write all of the digits to the display
 014  001D0                     LOAD s1, sD[Sensor]              ; update LEDs with new sensor information
 015  20170                     CALL 170[LED_wrleds]             ;               ;
 016  200C1                     CALL 0C1[next_step]              ; tell rojobot what to do next
 017  20060                     CALL 060[next_dp]                ;   display on dps
 018  0B620                     FETCH s6, 20[SP_SEM]
 019  19601                     SUB s6, 01                       ; decrement semaphore
 01A  2F620                     STORE s6, 20[SP_SEM]             ;
 01B  22009                     JUMP 009[main_L0]                ; } // end - main while loop
 01C                            ;**************************************************************************************
 01C                            ; Support functions
 01C                            ;**************************************************************************************
 01C                            ; ===============================================================================
 01C                            ; === wr_alldigits() - Writes all 4 display digits from the global registers  ===
 01C                            ; === Registers used s0,s1,s2, Dig0, Dig1, Dig2, Dig3                         ===
 01C                            ; ===============================================================================
 01C  01200       wr_alldigits: LOAD s2, 00                      ; point at digit 0
 01D  00170                     LOAD s1, s7[Dig0]                ; and write it to display
 01E  20174                     CALL 174[SS_wrdigx]              ;
 01F  01201                     LOAD s2, 01                      ; point at digit 1
 020  00180                     LOAD s1, s8[Dig1]                ; and write it to display
 021  20174                     CALL 174[SS_wrdigx]              ;
 022  01202                     LOAD s2, 02                      ; point at digit 2
 023  00190                     LOAD s1, s9[Dig2]                ; and write it to display
 024  20174                     CALL 174[SS_wrdigx]              ;
 025  01203                     LOAD s2, 03                      ; point at digit 3
 026  001A0                     LOAD s1, sA[Dig3]                ; and write it to the display
 027  20174                     CALL 174[SS_wrdigx]              ;
 028  25000                     RETURN 
 029                            ; ===============================================================================
 029                            ; === init_mvmttbl() - initialize movement translation lookup table in SP RAM ===
 029                            ; === Registers affected: s0, s1                                              ===
 029                            ; ===============================================================================
 029  01010       init_mvmttbl: LOAD s0, 10[SP_MVMTBASE]         ; s0 gets base of movement translation lookup table
 02A  01118                     LOAD s1, 18[SP_MVMT0]            ; s1 gets values for 0x00
 02B  2E100                     STORE s1, (s0)                   ; store the entry in the table
 02C  11001                     ADD s0, 01                       ; increment the table index
 02D  01117                     LOAD s1, 17[SP_MVMT1]            ; s1 gets values for 0x01
 02E  2E100                     STORE s1, (s0)                   ; store the entry in the table
 02F  11001                     ADD s0, 01                       ; increment the table index
 030  01117                     LOAD s1, 17[SP_MVMT2]            ; s1 gets values for 0x02
 031  2E100                     STORE s1, (s0)                   ; store the entry in the table
 032  11001                     ADD s0, 01                       ; increment the table index
 033  01117                     LOAD s1, 17[SP_MVMT3]            ; s1 gets values for 0x03
 034  2E100                     STORE s1, (s0)                   ; store the entry in the table
 035  11001                     ADD s0, 01                       ; increment the table index
 036  0110F                     LOAD s1, 0F[SP_MVMT4]            ; s1 gets values for 0x04
 037  2E100                     STORE s1, (s0)                   ; store the entry in the table
 038  11001                     ADD s0, 01                       ; increment the table index
 039  01117                     LOAD s1, 17[SP_MVMT5]            ; s1 gets values for 0x05
 03A  2E100                     STORE s1, (s0)                   ; store the entry in the table
 03B  11001                     ADD s0, 01                       ; increment the table index
 03C  01117                     LOAD s1, 17[SP_MVMT6]            ; s1 gets values for 0x06
 03D  2E100                     STORE s1, (s0)                   ; store the entry in the table
 03E  11001                     ADD s0, 01                       ; increment the table index
 03F  01117                     LOAD s1, 17[SP_MVMT7]            ; s1 gets values for 0x07
 040  2E100                     STORE s1, (s0)                   ; store the entry in the table
 041  11001                     ADD s0, 01                       ; increment the table index
 042  0110B                     LOAD s1, 0B[SP_MVMT8]            ; s1 gets values for 0x08
 043  2E100                     STORE s1, (s0)                   ; store the entry in the table
 044  11001                     ADD s0, 01                       ; increment the table index
 045  01117                     LOAD s1, 17[SP_MVMT9]            ; s1 gets values for 0x09
 046  2E100                     STORE s1, (s0)                   ; store the entry in the table
 047  11001                     ADD s0, 01                       ; increment the table index
 048  01117                     LOAD s1, 17[SP_MVMTA]            ; s1 gets values for 0x0A
 049  2E100                     STORE s1, (s0)                   ; store the entry in the table
 04A  11001                     ADD s0, 01                       ; increment the table index
 04B  01117                     LOAD s1, 17[SP_MVMTB]            ; s1 gets values for 0x0B
 04C  2E100                     STORE s1, (s0)                   ; store the entry in the table
 04D  11001                     ADD s0, 01                       ; increment the table index
 04E  01119                     LOAD s1, 19[SP_MVMTC]            ; s1 gets values for 0x0C
 04F  2E100                     STORE s1, (s0)                   ; store the entry in the table
 050  11001                     ADD s0, 01                       ; increment the table index
 051  0111B                     LOAD s1, 1B[SP_MVMTD]            ; s1 gets values for 0x0D
 052  2E100                     STORE s1, (s0)                   ; store the entry in the table
 053  11001                     ADD s0, 01                       ; increment the table index
 054  0111A                     LOAD s1, 1A[SP_MVMTE]            ; s1 gets values for 0x0E
 055  2E100                     STORE s1, (s0)                   ; store the entry in the table
 056  11001                     ADD s0, 01                       ; increment the table index
 057  0111C                     LOAD s1, 1C[SP_MVMTF]            ; s1 gets values for 0x0F
 058  2E100                     STORE s1, (s0)                   ; store the entry in the table
 059  25000                     RETURN                           ; done...at last
 05A                            ; =============================================================================
 05A                            ; === mvmt2cc() - movement to character code conversion function            ===
 05A                            ; === Registers affected: s1, s2                                            ===
 05A                            ; === s0 contains the movment value to convert.                             ===
 05A                            ; === Result (character code to display) is returned in s1                  ===
 05A                            ; === s0 (movement) is not changed                                          ===
 05A                            ; =============================================================================
 05A  01210            mvmt2cc: LOAD s2, 10[SP_MVMTBASE]         ; s2 gets base of movment conversion table
 05B  00100                     LOAD s1, s0                      ; mask out upper nibble of movment
 05C  0310F                     AND s1, 0F[MSKLOWNIB]            ;
 05D  10210                     ADD s2, s1                       ; s2 = Base + offset into table
 05E  0A120                     FETCH s1, (s2)                   ; and fetch the entry
 05F  25000                     RETURN 
 060                            ; ==============================================================================
 060                            ; === next_dp() - drive LEDs (flash dp[0] when stopped, otherwise all=chase) ===
 060                            ; ==============================================================================
 060  0B127            next_dp: FETCH s1, 27[SP_OLDDP]           ; get the old decimal point value
 061  0B00A                     FETCH s0, 0A[MODE]               ; get mode
 062  2D107                     OUTPUT s1, 07[PA_DP]             ; drive dps according to old value
 063  1D000                     COMPARE s0, 00                   ; is the mode undefined (stop)?
 064  3206D                     JUMP Z, 06D[dp_flashing]         ; yes: flash dp[0]
 065                            ; otherwise, chase right-to-left
 065  14106                     SL0 s1                           ;
 066  1D110                     COMPARE s1, 10                   ; loop when 4th dp is lit
 067  3206A                     JUMP Z, 06A[dp_loop]             ;
 068  2F127                     STORE s1, 27[SP_OLDDP]           ; store updated value
 069  25000                     RETURN 
 06A  01101            dp_loop: LOAD s1, 01                      ; reset to first dp
 06B  2F127                     STORE s1, 27[SP_OLDDP]           ; store updated value
 06C  25000                     RETURN 
 06D               dp_flashing: ; simply toggle between dp1 off/on
 06D  1D101                     COMPARE s1, 01
 06E  36072                     JUMP NZ, 072[dp_to_01]
 06F  01100                     LOAD s1, 00
 070  2F127                     STORE s1, 27[SP_OLDDP]
 071  25000                     RETURN 
 072  01101           dp_to_01: LOAD s1, 01
 073  2F127                     STORE s1, 27[SP_OLDDP]
 074  25000                     RETURN 
 075                            ; ========================================================================
 075                            ; === next_mvmt() - Calculate  digit for motion indicator              ===
 075                            ; === Registers affected: Dig3, s0                                     ===
 075                            ; === Uses Botinf (Bot Info register) to get movement.                 ===
 075                            ; ========================================================================
 075  000C0          next_mvmt: LOAD s0, sC[Botinf]              ; s0[3:0] = Botinf[7:4]
 076  1400E                     SR0 s0                           ;
 077  1400E                     SR0 s0                           ;
 078  1400E                     SR0 s0                           ;
 079  1400E                     SR0 s0                           ;
 07A  2005A                     CALL 05A[mvmt2cc]                ; translate movement to char code
 07B  00A10                     LOAD sA[Dig3], s1                ; and move to digit 3
 07C  25000                     RETURN 
 07D                            ; ==============================================================================
 07D                            ; === next_hdg() - Calculate  digits for heading (compass setting)           ===
 07D                            ; === Registers affected: Dig2, Dig1, Dig0, s0, s1, s2, s3,s4, s5, s6        ===
 07D                            ; === Uses Botinf (Bot Info register) to get orientation.  Calculates digits ===
 07D                            ; === with a case statement based on orientation.                            ===
 07D                            ; ==============================================================================
 07D  000C0           next_hdg: LOAD s0, sC[Botinf]              ; s0[2:0] = Botinf[2:0] = orientation
 07E  03007                     AND s0, 07[MSKORIENT]            ;
 07F                            ; switch(orientation)  {
 07F  1D000         nh_caseORN: COMPARE s0, 00[OR_N]             ; case(OR_N):
 080  36085                     JUMP NZ, 085[nh_caseORNE]        ;
 081  01400                     LOAD s4, 00                      ;  Dig[2:0] = 000
 082  01500                     LOAD s5, 00                      ;
 083  01600                     LOAD s6, 00                      ;
 084  220AC                     JUMP 0AC[nh_endcase]             ;  break;
 085                            ;
 085  1D001        nh_caseORNE: COMPARE s0, 01[OR_NE]            ; case (OR_NE):
 086  3608B                     JUMP NZ, 08B[nh_caseORE]         ;
 087  01400                     LOAD s4, 00                      ;  Dig[2:0] = 045
 088  01504                     LOAD s5, 04                      ;
 089  01605                     LOAD s6, 05                      ;
 08A  220AC                     JUMP 0AC[nh_endcase]             ;  break;
 08B  1D002         nh_caseORE: COMPARE s0, 02[OR_E]             ; case (OR_E):
 08C  36091                     JUMP NZ, 091[nh_caseORSE]        ;
 08D  01400                     LOAD s4, 00                      ;  Dig[2:0] = 090
 08E  01509                     LOAD s5, 09                      ;
 08F  01600                     LOAD s6, 00                      ;
 090  220AC                     JUMP 0AC[nh_endcase]             ;  break;
 091  1D003        nh_caseORSE: COMPARE s0, 03[OR_SE]            ; case (OR_SE):
 092  36097                     JUMP NZ, 097[nh_caseORS]         ;
 093  01401                     LOAD s4, 01                      ;  Dig[2:0] = 135
 094  01503                     LOAD s5, 03                      ;
 095  01605                     LOAD s6, 05                      ;
 096  220AC                     JUMP 0AC[nh_endcase]             ;  break;
 097  1D004         nh_caseORS: COMPARE s0, 04[OR_S]             ; case (OR_S):
 098  3609D                     JUMP NZ, 09D[nh_caseORSW]        ;
 099  01401                     LOAD s4, 01                      ;  Dig[2:0] = 180
 09A  01508                     LOAD s5, 08                      ;
 09B  01600                     LOAD s6, 00                      ;
 09C  220AC                     JUMP 0AC[nh_endcase]             ;  break;
 09D  1D005        nh_caseORSW: COMPARE s0, 05[OR_SW]            ; case (OR_SW):
 09E  360A3                     JUMP NZ, 0A3[nh_caseORW]         ;
 09F  01402                     LOAD s4, 02                      ;  Dig[2:0] = 225
 0A0  01502                     LOAD s5, 02                      ;
 0A1  01605                     LOAD s6, 05                      ;
 0A2  220AC                     JUMP 0AC[nh_endcase]             ;  break;
 0A3  1D006         nh_caseORW: COMPARE s0, 06[OR_W]             ; case (OR_W):
 0A4  360A9                     JUMP NZ, 0A9[nh_caseORNW]        ;
 0A5  01402                     LOAD s4, 02                      ;  Dig[2:0] = 270
 0A6  01507                     LOAD s5, 07                      ;
 0A7  01600                     LOAD s6, 00                      ;
 0A8  220AC                     JUMP 0AC[nh_endcase]             ;  break;
 0A9                            ; case (OR_NW):  // only remaining case
 0A9  01403        nh_caseORNW: LOAD s4, 03                      ;  Dig[2:0] = 315
 0AA  01501                     LOAD s5, 01                      ;
 0AB  01605                     LOAD s6, 05                      ;
 0AC                            ; } // end of switch statement
 0AC  00940         nh_endcase: LOAD s9[Dig2], s4                ;
 0AD  00850                     LOAD s8[Dig1], s5                ;
 0AE  00760                     LOAD s7[Dig0], s6                ;
 0AF  25000                     RETURN 
 0B0                            ; ==============================================================================
 0B0                            ; === next_loc() - Calculate digits for Rojobot location                     ===
 0B0                            ; === Registers affected: Dig3, Dig2, Dig1, Dig0, s0                         ===
 0B0                            ; === Uses LocX and LocY to get location.                                    ===
 0B0                            ; ==============================================================================
 0B0  000F0           next_loc: LOAD s0, sF[LocX]                ; Dig[3:2] gets X-coordinate
 0B1  00900                     LOAD s9[Dig2], s0                ; Digit 2 gets lower nibble
 0B2  0390F                     AND s9[Dig2], 0F[MSK_HEXDIGIT]   ;
 0B3  1400E                     SR0 s0                           ; Digit3 gets upper nibble
 0B4  1400E                     SR0 s0                           ;
 0B5  1400E                     SR0 s0                           ;
 0B6  1400E                     SR0 s0                           ;
 0B7  00A00                     LOAD sA[Dig3], s0                ;
 0B8  000E0                     LOAD s0, sE[LocY]                ; Dig[1:0] gets Y-coordinate
 0B9  00700                     LOAD s7[Dig0], s0                ; Digit 0 gets lower nibble
 0BA  0370F                     AND s7[Dig0], 0F[MSK_HEXDIGIT]   ;
 0BB  1400E                     SR0 s0                           ; Digit 1 gets upper nibble
 0BC  1400E                     SR0 s0                           ;
 0BD  1400E                     SR0 s0                           ;
 0BE  1400E                     SR0 s0                           ;
 0BF  00800                     LOAD s8[Dig1], s0                ;
 0C0  25000                     RETURN 
 0C1                            ; ==============================================================================
 0C1                            ; === next_step() -  read MODE register and run the subroutine corresponding to
 0C1                            ;      the set bit. if no bits set, fall through to error                           ===
 0C1                            ; ==============================================================================
 0C1  01000          next_step: LOAD s0, 00[MOVE_NOT]
 0C2  2D009                     OUTPUT s0, 09[PA_MOTCTL_IN]
 0C3  2016D                     CALL 16D[DEB_rdsw]
 0C4  0D002                     TEST s0, 02                      ; only proceed if switch[1] is on
 0C5  31000                     RETURN Z
 0C6  0B00A                     FETCH s0, 0A[MODE]               ; case statement based on MODE
 0C7  0D001                     TEST s0, 01[MODE_NORMAL]
 0C8  320CB                     JUMP Z, 0CB[next1]
 0C9  200E4                     CALL 0E4[normal_mode]
 0CA  25000                     RETURN 
 0CB  0D002              next1: TEST s0, 02[MODE_NOLINEREVERSE]
 0CC  320CF                     JUMP Z, 0CF[next2]
 0CD  200F8                     CALL 0F8[no_line_reverse]
 0CE  25000                     RETURN 
 0CF  0D004              next2: TEST s0, 04[MODE_TURN135L]
 0D0  320D3                     JUMP Z, 0D3[next3]
 0D1  20108                     CALL 108[turn_135L]
 0D2  25000                     RETURN 
 0D3  0D008              next3: TEST s0, 08[MODE_BEGINTEST]
 0D4  320D7                     JUMP Z, 0D7[next4]
 0D5  2011D                     CALL 11D[begin_test]
 0D6  25000                     RETURN 
 0D7  0D010              next4: TEST s0, 10[MODE_FORWARDTEST]
 0D8  320DB                     JUMP Z, 0DB[next5]
 0D9  20130                     CALL 130[forward_test]
 0DA  25000                     RETURN 
 0DB  0D020              next5: TEST s0, 20[MODE_FAILREVERSE]
 0DC  320DF                     JUMP Z, 0DF[next6]
 0DD  20148                     CALL 148[fail_reverse]
 0DE  25000                     RETURN 
 0DF  0D040              next6: TEST s0, 40[MODE_TURN45R]
 0E0  320E3                     JUMP Z, 0E3[error]
 0E1  20157                     CALL 157[turn_45R]
 0E2  25000                     RETURN 
 0E3                     error: ; default case
 0E3  25000                     RETURN 
 0E4                            ; ==============================================================================
 0E4                            ; normal_mode() go forward.  if blocked, stop.  if line is lost, stop and
 0E4                            ;    set mode to no_line_reverse
 0E4                            ; ==============================================================================
 0E4               normal_mode: 
 0E4  20164                     CALL 164[read_blackline]
 0E5  01007                     LOAD s0, 07
 0E6  1C010                     COMPARE s0, s1
 0E7  320EE                     JUMP Z, 0EE[n_noline]            ; jump if bot isnt on the line
 0E8  20167                     CALL 167[read_prox]
 0E9  1D100                     COMPARE s1, 00
 0EA  360F3                     JUMP NZ, 0F3[n_blocked]          ; jump if bot is blocked
 0EB  011FF                     LOAD s1, FF[MOVE_FF]             ; if on the line and not blocked,
 0EC  2D109                     OUTPUT s1, 09[PA_MOTCTL_IN]      ; continue moving forward
 0ED  25000                     RETURN 
 0EE                  n_noline: ; bot went off the line.  stop moving, set MODE=NOLINEREVERSE
 0EE  01100                     LOAD s1, 00[MOVE_NOT]
 0EF  2D109                     OUTPUT s1, 09[PA_MOTCTL_IN]
 0F0  01002                     LOAD s0, 02[MODE_NOLINEREVERSE]
 0F1  2F00A                     STORE s0, 0A[MODE]
 0F2  25000                     RETURN 
 0F3                 n_blocked: ; bot is blocked. clear MODE and return
 0F3  01100                     LOAD s1, 00[MOVE_NOT]
 0F4  2D109                     OUTPUT s1, 09[PA_MOTCTL_IN]
 0F5  01000                     LOAD s0, 00
 0F6  2F00A                     STORE s0, 0A[MODE]
 0F7  25000                     RETURN 
 0F8                            ; ==============================================================================
 0F8                            ; no_line_reverse() back up until the line is found.  once it is found, change
 0F8                            ;     the mode to turn_135L
 0F8                            ; ==============================================================================
 0F8           no_line_reverse: 
 0F8  20164                     CALL 164[read_blackline]
 0F9  1D100                     COMPARE s1, 00
 0FA  320FE                     JUMP Z, 0FE[nlr_found_line]      ; jump if the bot reversed back onto
 0FB                            ; the line
 0FB  01166                     LOAD s1, 66[MOVE_R]
 0FC  2D109                     OUTPUT s1, 09[PA_MOTCTL_IN]      ; otherwise, keep backing up
 0FD  25000                     RETURN 
 0FE            nlr_found_line: ; bot is back on the line again!
 0FE  01100                     LOAD s1, 00[MOVE_NOT]            ; first stop moving
 0FF  2D109                     OUTPUT s1, 09[PA_MOTCTL_IN]
 100  01004                     LOAD s0, 04[MODE_TURN135L]       ; update the mode
 101  2F00A                     STORE s0, 0A[MODE]
 102  000C0                     LOAD s0, sC[Botinf]
 103  03007                     AND s0, 07[MSKORIENT]
 104  2F007                     STORE s0, 07[SP_PREV_OR]         ; store the current orientation
 105  01000                     LOAD s0, 00                      ; and initialize the turn counter
 106  2F008                     STORE s0, 08[SP_TURN_COUNT]
 107  25000                     RETURN 
 108                            ; ==============================================================================
 108                            ; turn_135L() turn left until bot has rotated 135 degrees, then stop turning
 108                            ;    and change mode to begin_test
 108                            ; ==============================================================================
 108                 turn_135L: 
 108  001C0                     LOAD s1, sC[Botinf]              ; s1 =  bot info
 109  03107                     AND s1, 07[MSKORIENT]            ; s1 = current orientation
 10A  0B007                     FETCH s0, 07[SP_PREV_OR]         ; s0 = prev direction
 10B  1C010                     COMPARE s0, s1                   ;
 10C  32115                     JUMP Z, 115[keep_turning]        ; jump if current direction != previous direction
 10D                   rt_diff: 
 10D  2F107                     STORE s1, 07[SP_PREV_OR]         ; save new, orientation as previous
 10E  0B108                     FETCH s1, 08[SP_TURN_COUNT]      ; get the counter
 10F  11101                     ADD s1, 01                       ;
 110  2D102                     OUTPUT s1, 02[PA_LEDS]
 111  01003                     LOAD s0, 03                      ; number of turns to complete
 112  1C010                     COMPARE s0, s1                   ; have this many turns been completed?
 113  32118                     JUMP Z, 118[rt_3turns]           ; jump if done turning
 114  2F108                     STORE s1, 08[SP_TURN_COUNT]
 115              keep_turning: ; otherwise, keep turning
 115  01103                     LOAD s1, 03[TURN_L]
 116  2D109                     OUTPUT s1, 09[PA_MOTCTL_IN]
 117  25000                     RETURN 
 118  01100          rt_3turns: LOAD s1, 00[MOVE_NOT]            ; stop turning
 119  2D109                     OUTPUT s1, 09[PA_MOTCTL_IN]      ;
 11A  01008                     LOAD s0, 08[MODE_BEGINTEST]      ; update the mode
 11B  2F00A                     STORE s0, 0A[MODE]               ;
 11C  25000                     RETURN 
 11D                            ; ==============================================================================
 11D                            ; begin_test() store the bots location.  if the current direction isnt
 11D                            ;    blocked, change mode to forward_test.  If it is blocked, store
 11D                            ;    bots orientation, and change mode to turn_45R
 11D                            ; ==============================================================================
 11D                begin_test: 
 11D  2FF04                     STORE sF[LocX], 04[SP_ORIG_X]    ; store current location
 11E  2FE05                     STORE sE[LocY], 05[SP_ORIG_Y]    ;
 11F  20167                     CALL 167[read_prox]              ; is this way blocked?
 120                            ; clear the flags
 120  01201                     LOAD s2, 01
 121  01300                     LOAD s3, 00
 122  1C230                     COMPARE s2, s3
 123                            ; Z = 0 and C = 0
 123  1D100                     COMPARE s1, 00
 124  3612A                     JUMP NZ, 12A[bt_blocked]         ; jump if this way is blocked
 125  01010                     LOAD s0, 10[MODE_FORWARDTEST]    ; otherwise, update mode
 126  2F00A                     STORE s0, 0A[MODE]               ; so bot will drive in this
 127                            ; direction
 127  01133                     LOAD s1, 33[MOVE_F]              ;
 128  2D109                     OUTPUT s1, 09[PA_MOTCTL_IN]      ;
 129  25000                     RETURN 
 12A                bt_blocked: ; if bot is blocked, skip straight to turning
 12A  01040                     LOAD s0, 40[MODE_TURN45R]
 12B  2F00A                     STORE s0, 0A[MODE]               ;
 12C  000C0                     LOAD s0, sC[Botinf]              ; store orientation
 12D  03007                     AND s0, 07
 12E  2F006                     STORE s0, 06[SP_ORIG_O]
 12F  25000                     RETURN 
 130                            ; ==============================================================================
 130                            ; forward_test() drive forward until X and/or Y location change.  Once this
 130                            ;     change occurs, turn off the motors and check for the line
 130                            ;     under bot.  If present, set mode = normal.  If line is not
 130                            ;     present, set mode = fail_reverse.
 130                            ; ==============================================================================
 130              forward_test: 
 130  20164                     CALL 164[read_blackline]
 131  01007                     LOAD s0, 07
 132  1C010                     COMPARE s0, s1
 133  32145                     JUMP Z, 145[ft_noline]           ; jump if bot is not on the line
 134  01133                     LOAD s1, 33[MOVE_F]              ;
 135  2D109                     OUTPUT s1, 09[PA_MOTCTL_IN]      ;
 136                            ; next state = normal mode if location has changed or forward test if not
 136  0B004                     FETCH s0, 04[SP_ORIG_X]
 137  001F0                     LOAD s1, sF[LocX]
 138  1C010                     COMPARE s0, s1
 139  3213B                     JUMP Z, 13B[sameX]
 13A  2213F                     JUMP 13F[setmodenormal]
 13B                     sameX: 
 13B  0B005                     FETCH s0, 05[SP_ORIG_Y]
 13C  001E0                     LOAD s1, sE[LocY]
 13D  1C010                     COMPARE s0, s1
 13E  32142                     JUMP Z, 142[continuetest]
 13F             setmodenormal: 
 13F  01001                     LOAD s0, 01[MODE_NORMAL]         ;
 140  2F00A                     STORE s0, 0A[MODE]               ;
 141  25000                     RETURN 
 142              continuetest: 
 142  01010                     LOAD s0, 10[MODE_FORWARDTEST]    ;
 143  2F00A                     STORE s0, 0A[MODE]               ;
 144  25000                     RETURN 
 145                 ft_noline: 
 145  01020                     LOAD s0, 20[MODE_FAILREVERSE]    ;
 146  2F00A                     STORE s0, 0A[MODE]               ;
 147  25000                     RETURN 
 148                            ; ==============================================================================
 148                            ; fail_reverse() bot reverses until finding the line. once found, stop motors
 148                            ;     and set next mode = turn 45 right
 148                            ; ==============================================================================
 148              fail_reverse: 
 148  20164                     CALL 164[read_blackline]
 149  01007                     LOAD s0, 07
 14A  1C010                     COMPARE s0, s1
 14B  32154                     JUMP Z, 154[fr_noline]           ; check if bot is on the line
 14C                            ; yes, bot has backed onto a line -- just need to turn.
 14C  01040                     LOAD s0, 40[MODE_TURN45R]        ;
 14D  2F00A                     STORE s0, 0A[MODE]               ;
 14E  01130                     LOAD s1, 30[TURN_R]              ;
 14F  2D109                     OUTPUT s1, 09[PA_MOTCTL_IN]      ;
 150  000C0                     LOAD s0, sC[Botinf]              ; store current orientation
 151  03007                     AND s0, 07                       ; (it is used in turn_45R)
 152  2F006                     STORE s0, 06[SP_ORIG_O]
 153  25000                     RETURN 
 154                 fr_noline: 
 154                            ;not on a line.  keep going in reverse
 154  01166                     LOAD s1, 66[MOVE_R]              ;
 155  2D109                     OUTPUT s1, 09[PA_MOTCTL_IN]      ;
 156  25000                     RETURN 
 157                            ; ==============================================================================
 157                            ; turn_45R() until the bot has rotated 45 degrees, keep turning right.  Once
 157                            ;    the orientation has changed, set the mode = begin_test
 157                            ; ==============================================================================
 157                  turn_45R: 
 157                            ; check if bot turned
 157  0B106                     FETCH s1, 06[SP_ORIG_O]
 158  000C0                     LOAD s0, sC[Botinf]
 159  03007                     AND s0, 07
 15A  1C100                     COMPARE s1, s0
 15B  32161                     JUMP Z, 161[turn_not_complete]
 15C  01100                     LOAD s1, 00[MOVE_NOT]            ;
 15D  2D109                     OUTPUT s1, 09[PA_MOTCTL_IN]      ;
 15E  01008                     LOAD s0, 08[MODE_BEGINTEST]      ;
 15F  2F00A                     STORE s0, 0A[MODE]               ;
 160  25000                     RETURN 
 161         turn_not_complete: 
 161  01130                     LOAD s1, 30[TURN_R]              ;
 162  2D109                     OUTPUT s1, 09[PA_MOTCTL_IN]      ;
 163  25000                     RETURN 
 164                            ; ==============================================================================
 164                            ; read_blackline: read black line sensor and return result in s1
 164                            ; ==============================================================================
 164            read_blackline: 
 164  001D0                     LOAD s1, sD[Sensor]
 165  03107                     AND s1, 07[MSK_BL]
 166  25000                     RETURN 
 167                            ; ==============================================================================
 167                            ; read_prox: read prox sensor and return result in s1
 167                            ; ==============================================================================
 167                 read_prox: 
 167  001D0                     LOAD s1, sD[Sensor]
 168  03118                     AND s1, 18[MSK_PS]
 169  25000                     RETURN 
 16A                            ;*************************
 16A                            ; Nexys3 I/O Functions
 16A                            ;*************************
 16A                            ;---------------------
 16A                            ; DEB_rdbtns() - Reads the debounced pushbuttons
 16A                            ;
 16A                            ; Returns the 5 pushbuttons. The buttons are returned as follows
 16A                            ; (assuming the inputs to the I/O interface matches this order)
 16A                            ; example:
 16A                            ;    bit  7    6      5        4        3        2        1         0
 16A                            ;         r    r      r    btn_cntr  btn_left  btn_up  btn_right  btn_down
 16A                            ;
 16A                            ; where r = reserved. A value of 1 indicates that the button is pressed.
 16A                            ; A 0 indicates that the button is not pressed.
 16A                            ;
 16A                            ; Registers used s0
 16A                            ;---------------------
 16A  09000         DEB_rdbtns: INPUT s0, 00[PA_PBTNS]           ; read the buttons
 16B  0301F                     AND s0, 1F[MSK_ALLBTNS]          ; mask out unused bits
 16C  25000                     RETURN                           ; and return
 16D                            ;---------------------
 16D                            ; DEB_rdsw() - Reads the debounced switches
 16D                            ;
 16D                            ; Returns the four switches in s0. The buttons are returned as follows
 16D                            ; (assuming the inputs match the order in the pb_rot_7Segemu
 16D                            ; example:
 16D                            ;    bit  7    6    5   4    3    2    1    0
 16D                            ;        sw7  sw6  sw5 sw4  sw3  sw2  sw1  sw0
 16D                            ;
 16D                            ; where r = reserved, sw7 is the leftmost switch and sw0 is the rightmost
 16D                            ; switch. A value of 1 indicates that the switch is on (up).  A 0 indicates that
 16D                            ; the switch is off (down).
 16D                            ;
 16D                            ; Registers used s0
 16D                            ;---------------------
 16D  09001           DEB_rdsw: INPUT s0, 01[PA_SLSWTCH]         ; read the slide switches
 16E  030FF                     AND s0, FF[MSK_ALLSW]            ; mask out unused bits
 16F  25000                     RETURN                           ; and return
 170                            ;---------------------
 170                            ; LED_wrleds() - Write the LEDs
 170                            ;
 170                            ; Writes the pattern in s1 to the LEDs
 170                            ;
 170                            ; Registers used s0, s1
 170                            ;---------------------
 170  00010         LED_wrleds: LOAD s0, s1                      ; Copy LEDs to s0 to preserve them
 171  030FF                     AND s0, FF[MSK_LEDS]             ; mask out unused bits
 172  2D002                     OUTPUT s0, 02[PA_LEDS]           ; and write pattern to the LEDs
 173  25000                     RETURN                           ; and return
 174                            ;---------------------
 174                            ; SS_wrdigx() - Write a digit to the display
 174                            ;
 174                            ; Writes the value specified in s1 to the digit number
 174                            ; in s2.  The digit number must be 0, 1, 2, or 3.  All
 174                            ; others numbers will be rejected.
 174                            ;
 174                            ; Registers used s0, s1, s2, s3
 174                            ;---------------------
 174  1D204          SS_wrdigx: COMPARE s2, 04                   ; check if the digit number is in range
 175  3D000                     RETURN NC                        ; C=0 says s1 >= 04 - out of range so return
 176  01006                     LOAD s0, 06[PA_DIG0]             ; calculate port address by starting with port address for digit 0
 177  18020                     SUB s0, s2                       ; next subtract out the digit number.  This will give the port address
 178                            ; for the selected digit.  Cool - it works because the port
 178                            ; addresses for the digits are consecutive starting with digit 3
 178  00310                     LOAD s3, s1                      ; Copy the value to s3 so we can leave it unchanged
 179  0331F                     AND s3, 1F[MSK_CCODE]            ; mask out unused character code bits
 17A  2C300                     OUTPUT s3, (s0)                  ; abd write the digit to the display at the port pointed to by s0
 17B  25000                     RETURN 
 17C                            ;---------------------
 17C                            ; SS_wrdpts() - Write the decimal points to the display
 17C                            ;
 17C                            ; Writes the decimal points specified in s1 to the display.
 17C                            ; The decimal point register is formatted as follows:
 17C                            ;    bit   7    6    5    4     3     2     1     0
 17C                            ;          r    r    r    r    dp3   dp2   dp1   dp0
 17C                            ;
 17C                            ; where r = reserved, dp3 (leftmost), dp2, dp1 dp0 (rightmost) = 1
 17C                            ; lights the decimal point. A 0 in the position turns off the decimal point
 17C                            ;
 17C                            ; Registers used s0,s1
 17C                            ;---------------------
 17C  00010          SS_wrdpts: LOAD s0, s1                      ; Copy the decimal points to s0 to leave s1 unchanged
 17D  0300F                     AND s0, 0F[MSK_DECPTS]           ; and mask out the unused bits
 17E  2D007                     OUTPUT s0, 07[PA_DP]             ; write the decimal points to the display
 17F  25000                     RETURN 
 180                            ;---------------------
 180                            ; SS_wrall() - Write all of the digits and decimal points to the display
 180                            ;
 180                            ; Writes all of the digits and decimal points to the display.  The values of the
 180                            ; digits and decimal point will be taken from 5 consecutive locations in the
 180                            ; PicoBlaze scratchpad RAM starting with the byte pointed to by s1.
 180                            ; Digits are arranged as follows:
 180                            ; (s1) Dig0
 180                            ; (s1+1) Dig1
 180                            ; (s1+2) Dig2
 180                            ; (s1+3) Dig3
 180                            ; (s1+4) Decimal points {dp3, dp2, dp1, dp0}
 180                            ;
 180                            ; Registers used s0, s1, s2, s3, s4
 180                            ;---------------------
 180  00410           SS_wrall: LOAD s4, s1                      ; Copy the SP RAM pointer to s4 to preserve SP RAM offset
 181  0A140                     FETCH s1, (s4)                   ; get digit 0. s4 points to it
 182  01200                     LOAD s2, 00                      ; tell SS_wrdigx to write digit 0
 183  20174                     CALL 174[SS_wrdigx]              ; and write the character
 184                            ;
 184  11401                     ADD s4, 01                       ; point to digit 1
 185  0A140                     FETCH s1, (s4)                   ; fetch if from the SP RAM
 186  01201                     LOAD s2, 01                      ; tell SS_wrdigx to write digit 1
 187  20174                     CALL 174[SS_wrdigx]              ; and write the character
 188                            ;
 188  11401                     ADD s4, 01                       ; point to digit 2
 189  0A140                     FETCH s1, (s4)                   ; fetch if from the SP RAM
 18A  01202                     LOAD s2, 02                      ; tell SS_wrdigx to write digit 2
 18B  20174                     CALL 174[SS_wrdigx]              ; and write the character
 18C                            ;
 18C  11401                     ADD s4, 01                       ; point to digit 3
 18D  0A140                     FETCH s1, (s4)                   ; fetch if from the SP RAM
 18E  01203                     LOAD s2, 03                      ; tell SS_wrdigx to write digit 3
 18F  20174                     CALL 174[SS_wrdigx]              ; and write the character
 190                            ;
 190  11401                     ADD s4, 01                       ; point to decimal points
 191  0A140                     FETCH s1, (s4)                   ; and fetch vector from the SP RAM
 192  2017C                     CALL 17C[SS_wrdpts]              ; write the decimal points to display
 193  25000                     RETURN 
 194                            ; =========================
 194                            ; === Interrupt Handler ===
 194                            ; =========================
 300                            ADDRESS 300
 300  2F621                isr: STORE s6, 21[SP_TEMP1]           ;  save s6, s5
 301  2F522                     STORE s5, 22[SP_TEMP2]           ;
 302  0B620                     FETCH s6, 20[SP_SEM]             ;  fetch the semaphore
 303  0D6FF                     TEST s6, FF                      ; if (SP_SEM == 0) {  // update system register values
 304  3630F                     JUMP NZ, 30F[isr_L0]             ; -- ZF == 0 says semaphore != 0
 305                            ;  // no - get the data from the rojobot emulator
 305  09F0A                     INPUT sF[LocX], 0A[PA_LOCX]      ;  get Rojobot X-coordinate
 306  09E0B                     INPUT sE[LocY], 0B[PA_LOCY]      ;  get Rojobot Y-coordinate
 307  09C0C                     INPUT sC[Botinf], 0C[PA_BOTINFO] ;  get Rojobot Movement and Orientation
 308  09D0D                     INPUT sD[Sensor], 0D[PA_SENSORS] ;  get Rojobot Sensors
 309  0950E                     INPUT s5, 0E[PA_LMDIST]          ;  get left and right motor distance counters
 30A  2F523                     STORE s5, 23[SP_LMDIST]          ;  not displayed in this program but let's stash them
 30B  0950F                     INPUT s5, 0F[PA_RMDIST]          ;  in case we decide we need them in lab 2 or 3
 30C  2F524                     STORE s5, 24[SP_RMDIST]          ;
 30D  11601                     ADD s6, 01                       ;  increment semaphore
 30E  2F620                     STORE s6, 20[SP_SEM]             ; }  // update system register values
 30F  0B521             isr_L0: FETCH s5, 21[SP_TEMP1]           ;  restore s6, s5
 310  0B622                     FETCH s6, 22[SP_TEMP2]           ;
 311  29001                     RETURNI ENABLE                   ; and return from interrupt
 312                            ; ========================
 312                            ; === Interrupt vector ===
 312                            ; ========================
 3FF                            ADDRESS 3FF
 3FF  22300            intvect: JUMP 300[isr]                    ; jump to interrupt service routine



List of PSM files that have been assembled

C:\ece540_final\rojobot_world\hardware\firmware\bot_control.psm



List of defined constants

 CONSTANT name      Value        Source PSM File

 timestamp_hours    19'd         
 timestamp_minutes  44'd         
 timestamp_seconds  57'd         
 datestamp_year     12'd         
 datestamp_month    11'd         
 datestamp_day      15'd         
 PA_PBTNS           00           bot_control.psm
 PA_SLSWTCH         01           bot_control.psm
 PA_LEDS            02           bot_control.psm
 PA_DIG3            03           bot_control.psm
 PA_DIG2            04           bot_control.psm
 PA_DIG1            05           bot_control.psm
 PA_DIG0            06           bot_control.psm
 PA_DP              07           bot_control.psm
 PA_RSVD            08           bot_control.psm
 PA_MOTCTL_IN       09           bot_control.psm
 PA_LOCX            0A           bot_control.psm
 PA_LOCY            0B           bot_control.psm
 PA_BOTINFO         0C           bot_control.psm
 PA_SENSORS         0D           bot_control.psm
 PA_LMDIST          0E           bot_control.psm
 PA_RMDIST          0F           bot_control.psm
 MSK_ALLBTNS        1F           bot_control.psm
 MSK_PBTNS          0F           bot_control.psm
 MSK_BTN_CENTER     10           bot_control.psm
 MSK_BTN_LEFT       08           bot_control.psm
 MSK_BTN_UP         04           bot_control.psm
 MSK_BTN_RIGHT      02           bot_control.psm
 MSK_BTN_DOWN       01           bot_control.psm
 MSK_ALLSW          FF           bot_control.psm
 MSK_SW7            80           bot_control.psm
 MSK_SW6            40           bot_control.psm
 MSK_SW5            20           bot_control.psm
 MSK_SW4            10           bot_control.psm
 MSK_SW3            08           bot_control.psm
 MSK_SW2            04           bot_control.psm
 MSK_SW1            02           bot_control.psm
 MSK_SW0            01           bot_control.psm
 MSK_LEDS           FF           bot_control.psm
 MSK_CCODE          1F           bot_control.psm
 MSK_DECPTS         0F           bot_control.psm
 MSK_HEXDIGIT       0F           bot_control.psm
 MSKLOWNIB          0F           bot_control.psm
 MSKHIGHNIB         F0           bot_control.psm
 INVLOWNIB          0F           bot_control.psm
 MSK_BL             07           bot_control.psm
 MSK_PS             18           bot_control.psm
 MSKORIENT          07           bot_control.psm
 MOVE_NOT           00           bot_control.psm
 MOVE_F             33           bot_control.psm
 MOVE_R             66           bot_control.psm
 TURN_R             30           bot_control.psm
 TURN_L             03           bot_control.psm
 MOVE_FF            FF           bot_control.psm
 MODE_NORMAL        01           bot_control.psm
 MODE_NOLINEREVERSE 02           bot_control.psm
 MODE_TURN135L      04           bot_control.psm
 MODE_BEGINTEST     08           bot_control.psm
 MODE_FORWARDTEST   10           bot_control.psm
 MODE_FAILREVERSE   20           bot_control.psm
 MODE_TURN45R       40           bot_control.psm
 FALSE              00           bot_control.psm
 TRUE               01           bot_control.psm
 NULL               00           bot_control.psm
 CC_BASE            10           bot_control.psm
 CC_SEGBASE         10           bot_control.psm
 CC_SEGA            10           bot_control.psm
 CC_SEGB            11           bot_control.psm
 CC_SEGC            12           bot_control.psm
 CC_SEGD            13           bot_control.psm
 CC_SEGE            14           bot_control.psm
 CC_SEGF            15           bot_control.psm
 CC_SEGG            16           bot_control.psm
 CC_DOT             17           bot_control.psm
 CC_UCH             18           bot_control.psm
 CC_UCL             19           bot_control.psm
 CC_UCR             1A           bot_control.psm
 CC_LCL             1B           bot_control.psm
 CC_LCR             1C           bot_control.psm
 CC_SPACE1          1D           bot_control.psm
 CC_SPACE2          1E           bot_control.psm
 CC_SPACE           1F           bot_control.psm
 OR_N               00           bot_control.psm
 OR_NE              01           bot_control.psm
 OR_E               02           bot_control.psm
 OR_SE              03           bot_control.psm
 OR_S               04           bot_control.psm
 OR_SW              05           bot_control.psm
 OR_W               06           bot_control.psm
 OR_NW              07           bot_control.psm
 MV_STOP            00           bot_control.psm
 MV_FWD             04           bot_control.psm
 MV_REV             08           bot_control.psm
 MV_SLT             0C           bot_control.psm
 MV_FLT             0D           bot_control.psm
 MV_SRT             0E           bot_control.psm
 MV_FRT             0F           bot_control.psm
 SP_MVMTBASE        10           bot_control.psm
 SP_MVMT0           18           bot_control.psm
 SP_MVMT1           17           bot_control.psm
 SP_MVMT2           17           bot_control.psm
 SP_MVMT3           17           bot_control.psm
 SP_MVMT4           0F           bot_control.psm
 SP_MVMT5           17           bot_control.psm
 SP_MVMT6           17           bot_control.psm
 SP_MVMT7           17           bot_control.psm
 SP_MVMT8           0B           bot_control.psm
 SP_MVMT9           17           bot_control.psm
 SP_MVMTA           17           bot_control.psm
 SP_MVMTB           17           bot_control.psm
 SP_MVMTC           19           bot_control.psm
 SP_MVMTD           1B           bot_control.psm
 SP_MVMTE           1A           bot_control.psm
 SP_MVMTF           1C           bot_control.psm
 SP_SEM             20           bot_control.psm
 SP_TEMP1           21           bot_control.psm
 SP_TEMP2           22           bot_control.psm
 SP_LMDIST          23           bot_control.psm
 SP_RMDIST          24           bot_control.psm
 SP_OLDMVMT         25           bot_control.psm
 SP_OLDHDG          26           bot_control.psm
 SP_OLDDP           27           bot_control.psm
 SP_ORIG_X          04           bot_control.psm
 SP_ORIG_Y          05           bot_control.psm
 SP_ORIG_O          06           bot_control.psm
 SP_PREV_OR         07           bot_control.psm
 SP_TURN_COUNT      08           bot_control.psm
 MODE               0A           bot_control.psm
 TEMP_COUNT         09           bot_control.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.00"        
 datestamp$        "15 Nov 2012"  
 timestamp$        "19:44:57"     



List of line labels

 Label               Addr  Source PSM File

 main_L0             009   bot_control.psm
 main_L1             011   bot_control.psm
 main_L2             013   bot_control.psm
 wr_alldigits        01C   bot_control.psm
 init_mvmttbl        029   bot_control.psm
 mvmt2cc             05A   bot_control.psm
 next_dp             060   bot_control.psm
 dp_loop             06A   bot_control.psm
 dp_flashing         06D   bot_control.psm
 dp_to_01            072   bot_control.psm
 next_mvmt           075   bot_control.psm
 next_hdg            07D   bot_control.psm
 nh_caseORN          07F   bot_control.psm
 nh_caseORNE         085   bot_control.psm
 nh_caseORE          08B   bot_control.psm
 nh_caseORSE         091   bot_control.psm
 nh_caseORS          097   bot_control.psm
 nh_caseORSW         09D   bot_control.psm
 nh_caseORW          0A3   bot_control.psm
 nh_caseORNW         0A9   bot_control.psm
 nh_endcase          0AC   bot_control.psm
 next_loc            0B0   bot_control.psm
 next_step           0C1   bot_control.psm
 next1               0CB   bot_control.psm
 next2               0CF   bot_control.psm
 next3               0D3   bot_control.psm
 next4               0D7   bot_control.psm
 next5               0DB   bot_control.psm
 next6               0DF   bot_control.psm
 error               0E3   bot_control.psm
 normal_mode         0E4   bot_control.psm
 n_noline            0EE   bot_control.psm
 n_blocked           0F3   bot_control.psm
 no_line_reverse     0F8   bot_control.psm
 nlr_found_line      0FE   bot_control.psm
 turn_135L           108   bot_control.psm
 rt_diff             10D   bot_control.psm
 keep_turning        115   bot_control.psm
 rt_3turns           118   bot_control.psm
 begin_test          11D   bot_control.psm
 bt_blocked          12A   bot_control.psm
 forward_test        130   bot_control.psm
 sameX               13B   bot_control.psm
 setmodenormal       13F   bot_control.psm
 continuetest        142   bot_control.psm
 ft_noline           145   bot_control.psm
 fail_reverse        148   bot_control.psm
 fr_noline           154   bot_control.psm
 turn_45R            157   bot_control.psm
 turn_not_complete   161   bot_control.psm
 read_blackline      164   bot_control.psm
 read_prox           167   bot_control.psm
 DEB_rdbtns          16A   bot_control.psm
 DEB_rdsw            16D   bot_control.psm
 LED_wrleds          170   bot_control.psm
 SS_wrdigx           174   bot_control.psm
 SS_wrdpts           17C   bot_control.psm
 SS_wrall            180   bot_control.psm
 isr                 300   bot_control.psm
 isr_L0              30F   bot_control.psm
 intvect             3FF   bot_control.psm



End of KCPSM6 log file.
