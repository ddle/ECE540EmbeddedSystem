KCPSM6 Assembler log file for program 'C:\ece540_final\rojobot_world\hardware\firmware\proj2demo.psm'.
Generated by KCPSM6 version v2.00
Ken Chapman - Xilinx Ltd - 30th April 2012

Assembly datestamp: 29 Oct 2012
Assembly timestamp: 09:55:04

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels


Last occupied address: 3FF hex
Nominal program memory size: 1K    address(9:0)


Assembly listing

 Addr Code                   Instruction

 000                         ; -----------------------------------------------------------------
 000                         ; proj2demo.psm - Demo program for Rojobot "world" emulator
 000                         ;
 000                         ; Author: Roy Kravitz
 000                         ; Version: 1.2
 000                         ; Date:  24-Oct-12
 000                         ;
 000                         ; Revision History
 000                         ; ================
 000                         ; 11-Jan-07  RK  Created the first version
 000                         ; 12-Jan-09  RK  Modified for S3E Starter Board and Seven Segment Emulator
 000                         ; 16-Oct-09  RK  Minor changes (comments) for PSU ECE510
 000                         ; 24-Oct-11  RK  Minor changes (comments)
 000                         ; 24-Oct-12  RK  Modified for kcpsm6 and Nexys 3
 000                         ;
 000                         ; Description:
 000                         ; ============
 000                         ; This program demonstrate the Rojobot world emulator.  It is modelled after
 000                         ; the the Verilog Rojobot implemented in Project 1 only this demo is based on the
 000                         ; full Rojobot emulator (asimplemented in bot.v instead of the simplified
 000                         ; rojobot model used in Project 1.
 000                         ;
 000                         ; The demo uses the 4 pushbuttons to control the Rojobot as follows:
 000                         ; btn_left - Left Motor forward
 000                         ;  btn_up  - Left Motor reverse
 000                         ; btn_right - Right Motor forward
 000                         ; btn_down - Right Motor reverse
 000                         ; If neither of the two buttons that control each motor is pushed, then the motor is stopped.
 000                         ; If both of the two buttons that control each motor are pushed, the actions cancel each other
 000                         ; leaving the motor stopped.
 000                         ;
 000                         ; The demo has two display modes.  When switch[0] is 'off' the program displays the
 000                         ; location of the Rojobot in its "world" on the 4 digits of the 7-segment display.
 000                         ; The leftmost two digits (digit 3 and digit 2) display the x-coordinate in Hex.
 000                         ; The rightmost two digits (digit 1 and digit 0) display the y-coordinate in Hex.
 000                         ;
 000                         ; When switch[0] is 'on' the program uses the 4 7-segment display digits as follows
 000                         ;  digit[3] Indicates the Rojobot movement (Stopped, Forward, Reverse, etc.) in Hex.  See the
 000                         ;     BotSim specification for the encoding (page 7)
 000                         ; digits[2:0] Indicates the Rojobot's heading in degrees.
 000                         ; The sensors are displayed on the LEDs in both display modes.
 000                         ; Decimal point 0 toggles on and off every interrupt (~every 100 msec)
 000                         ;
 000                         ; NOTE:  NOT ALL THE CODE IN THIS EXAMPLE IS USED.  THE EXAMPLE WAS CREATED TO GIVE YOU, THE
 000                         ; STUDENT, AN EXAMPLE OF HOW TO CONTROL THE ROJOBOT AND S3E PERIPHERALS FROM AN EMBEDDED PICOBLAZE
 000                         ; CPU. YOU MAY (OR NOT) FIND SOME OF THIS CODE APPLICABLE TO YOUR OTHER PROJECTS
 000                         ; -----------------------------------------------------------------
 000                         ; ============================================
 000                         ; === Register Names                       ===
 000                         ; === s6 - s0 registers are not dedicated  ===
 000                         ; === and keep their default names         ===
 000                         ; ============================================
 000                         NAMEREG sF, LocX                 ; rojobot location - x coordinate
 000                         NAMEREG sE, LocY                 ; rojobot location - y coordinate
 000                         NAMEREG sD, Sensor               ; rojobot sensor values
 000                         NAMEREG sC, Botinf               ; rojobot movement and orientation values
 000                         NAMEREG sB, MVst                 ; state variable for movement indicator
 000                         NAMEREG sA, Dig3                 ; 7-segment display digit 3
 000                         NAMEREG s9, Dig2                 ; 7-segment display digit 2
 000                         NAMEREG s8, Dig1                 ; 7-segment display digit 1
 000                         NAMEREG s7, Dig0                 ; 7-segment display digit 0
 000                         ; ======================
 000                         ; === Port Addresses ===
 000                         ; ======================
 000                         ; s3e board interface ports
 000                         ;  Port Addresses
 000                         CONSTANT PA_LEDS, 10             ; (o) LEDs
 000                         CONSTANT PA_DIG3, 02             ; (o) digit 3 PA address
 000                         CONSTANT PA_DIG2, 04             ; (o) digit 2 PA address
 000                         CONSTANT PA_DIG1, 08             ; (o) digit 1 PA address
 000                         CONSTANT PA_DIG0, 10             ; (o) digit 0 PA address
 000                         CONSTANT PA_DP, 20               ; (o) decimal points PA address
 000                         CONSTANT PA_RSVD, 40             ; (o) *RESERVED*
 000                         CONSTANT PA_MOTCTL_IN, 80        ; (o) Rojobot motor control output from system
 000                         CONSTANT PA_PBTNS, 00            ; (i) pushbuttons and rotary encoder direction and pushbutton
 000                         CONSTANT PA_SLSWTCH, 01          ; (i) slide switches
 000                         CONSTANT PA_LOCX, 02             ; (i) X coordinate of rojobot location
 000                         CONSTANT PA_LOCY, 03             ; (i))Y coordinate of rojobot location
 000                         CONSTANT PA_BOTINFO, 04          ; (i) Rojobot info register
 000                         CONSTANT PA_SENSORS, 05          ; (i) Sensor register
 000                         CONSTANT PA_LMDIST, 06           ; (i) Rojobot left motor distance register
 000                         CONSTANT PA_RMDIST, 07           ; (i) Rojobot right motor distance register
 000                         ; =====================================
 000                         ; === Register bit mappings (masks) ===
 000                         ; =====================================
 000                         ;  bit masks for pushbuttons and switches for seven segment emulator
 000                         CONSTANT MSK_ALLBTNS, 1F         ; Buttons are in bits[5:0]
 000                         CONSTANT MSK_PBTNS, 0F           ; Mask for 4 buttons to display on LED
 000                         CONSTANT MSK_BTN_CENTER, 10      ; Pushbutton Center is bit 4
 000                         CONSTANT MSK_BTN_LEFT, 08        ; Pushbutton Left is bit 3
 000                         CONSTANT MSK_BTN_UP, 04          ; Pushbutton Up is bit 2
 000                         CONSTANT MSK_BTN_RIGHT, 02       ; Pushbutton Right is bit 1
 000                         CONSTANT MSK_BTN_DOWN, 01        ; Pusbhbutton Down is bit 0
 000                         CONSTANT MSK_ALLSW, FF           ; Slide switches are in bits[7:0]
 000                         CONSTANT MSK_SW7, 80             ; Slide switch 7 is bit 7
 000                         CONSTANT MSK_SW6, 40             ; Slide switch 6 is bit 6
 000                         CONSTANT MSK_SW5, 20             ; Slide switch 5 is bit 5
 000                         CONSTANT MSK_SW4, 10             ; Slide switch 4 is bit 4
 000                         CONSTANT MSK_SW3, 08             ; Slide switch 3 is bit 3
 000                         CONSTANT MSK_SW2, 04             ; Slide switch 2 is bit 2
 000                         CONSTANT MSK_SW1, 02             ; Slide switch 1 is bit 1
 000                         CONSTANT MSK_SW0, 01             ; Slide switch 0 is bit 0
 000                         ; bit mask for LEDs
 000                         CONSTANT MSK_LEDS, FF            ; There are 8 LEDs on the Nexys 3
 000                         ; bit mask for display character codes and decimal points
 000                         CONSTANT MSK_CCODE, 1F           ; Character codes are in lower 5 bits
 000                         CONSTANT MSK_DECPTS, 0F          ; Decimal points are in bits 3 to 0
 000                         CONSTANT MSK_HEXDIGIT, 0F        ; Hex digits only take 4 bits
 000                         ; nibble masks
 000                         CONSTANT MSKLOWNIB, 0F           ; Mask out high nibble of byte
 000                         CONSTANT MSKHIGHNIB, F0          ; Mask out low nibble of byte
 000                         CONSTANT INVLOWNIB, 0F           ; Invert low nibble of byte
 000                         ; =============================
 000                         ; === Useful Data Constants ===
 000                         ; =============================
 000                         ;  Constants for True and False and Null
 000                         CONSTANT FALSE, 00
 000                         CONSTANT TRUE, 01
 000                         CONSTANT NULL, 00
 000                         ; Character code table for special characters
 000                         ; Decimal digits 0 to 15 display '0'to 'F'
 000                         CONSTANT CC_BASE, 10             ; Base value for special characters
 000                         CONSTANT CC_SEGBASE, 10          ; Base value for segment display special characters
 000                         ;     abcdefg
 000                         CONSTANT CC_SEGA, 10             ; Segment A  [1000000]
 000                         CONSTANT CC_SEGB, 11             ; Segment B  [0100000]
 000                         CONSTANT CC_SEGC, 12             ; Segment C  [0010000]
 000                         CONSTANT CC_SEGD, 13             ; Segment D  [0001000]
 000                         CONSTANT CC_SEGE, 14             ; Segment E  [0000100]
 000                         CONSTANT CC_SEGF, 15             ; Segment F  [0000010]
 000                         CONSTANT CC_SEGG, 16             ; Segment G  [0000001]
 000                         CONSTANT CC_DOT, 17              ; Dot (period)
 000                         CONSTANT CC_UCH, 18              ; Upper Case H
 000                         CONSTANT CC_UCL, 19              ; Upper Case L
 000                         CONSTANT CC_UCR, 1A              ; Upper Case R
 000                         CONSTANT CC_LCL, 1B              ; Lower Case L
 000                         CONSTANT CC_LCR, 1C              ; Lower Case R
 000                         CONSTANT CC_SPACE1, 1D           ; Space (blank)
 000                         CONSTANT CC_SPACE2, 1E           ; Space (blank)
 000                         CONSTANT CC_SPACE, 1F            ; Space (blank)
 000                         ; ======================
 000                         ; === BotInfo values ===
 000                         ; ======================
 000                         CONSTANT OR_N, 00                ; Orientation is North
 000                         CONSTANT OR_NE, 01               ; Orientation is Northeast
 000                         CONSTANT OR_E, 02                ; Orientation is East
 000                         CONSTANT OR_SE, 03               ; Orientation is Southeast
 000                         CONSTANT OR_S, 04                ; Orientation is South
 000                         CONSTANT OR_SW, 05               ; Orientation is Southwest
 000                         CONSTANT OR_W, 06                ; Orientation is West
 000                         CONSTANT OR_NW, 07               ; Orientation is Northwest
 000                         CONSTANT MV_STOP, 00             ; Movement is stopped
 000                         CONSTANT MV_FWD, 04              ; Movement is forward
 000                         CONSTANT MV_REV, 08              ; Movement is reverse
 000                         CONSTANT MV_SLT, 0C              ; Movement is slow left turn
 000                         CONSTANT MV_FLT, 0D              ; Movement is fast left turn
 000                         CONSTANT MV_SRT, 0E              ; Movement is slow right turn
 000                         CONSTANT MV_FRT, 0F              ; Movement is fast right turn
 000                         ; Next 2 contants assume field is in low nibble
 000                         CONSTANT MSKMVMT, 0F             ; Mask out all but movement bits
 000                         CONSTANT MSKORIENT, 07           ; Mask out all but orientation bits
 000                         ; =================================
 000                         ; === Scratch Pad RAM Variables ===
 000                         ; =================================
 000                         ; Pushbutton translation lookup table.  Converts pushbutton combos
 000                         ; to Motor Control input register format [lmspd[2:0],lmdir,rmspd[2:0],rmdir]
 000                         CONSTANT SP_BTNBASE, 00          ; table is based at 0x00
 000                         ;        [b3,b2,b1,b0]=[lf,lr,rf,rr]
 000                         CONSTANT SP_LSRS, 00             ; left motor off, right motor off     [0000]
 000                         CONSTANT SP_LORR, 02             ; left motor off, right motor reverse   [0001]
 000                         CONSTANT SP_LSRF, 03             ; left motor off, right motor forward   [0010]
 000                         CONSTANT SP_LSRFR, 00            ; left motor off, right motor fwd & rev = off [0011]
 000                         CONSTANT SP_LRRS, 20             ; left motor reverse, right motor off   [0100]
 000                         CONSTANT SP_LRRR, 22             ; left motor reverse, right motor reverse  [0101]
 000                         CONSTANT SP_LRRF, 23             ; left motor reverse, right motor forward  [0110]
 000                         CONSTANT SP_LRRFR, 20            ; left motor rev, right motor fwd & rev = off [0111]
 000                         CONSTANT SP_LFRS, 30             ; left motor forward, right motor off    [1000]
 000                         CONSTANT SP_LFRR, 32             ; left motor forward, right motor reverse  [1001]
 000                         CONSTANT SP_LFRF, 33             ; left motor forward, right motor forward  [1010]
 000                         CONSTANT SP_LFRFR, 30            ; left motor fwd, right motor fwd & rev = off [1011]
 000                         CONSTANT SP_LFRRS, 00            ; left motor fwd & rev = off, right motor off [1100]
 000                         CONSTANT SP_LFRRR, 02            ; left motor fwd & rev = off, right motor rev [1101]
 000                         CONSTANT SP_LFRRF, 03            ; left motor fwd & rev = off, right motor fwd [1110]
 000                         CONSTANT SP_LFRRFR, 00           ; left  and right motor fwd & rev = off   [1111]
 000                         ; Movement display lookup table.  Converts movement from BotInfo register to
 000                         ; the character code to display.  Not very dense but we have the room in the SP RAM and
 000                         ; it saves building a switch statement into the code.
 000                         CONSTANT SP_MVMTBASE, 10         ; table is based at 0x10
 000                         CONSTANT SP_MVMT0, 18            ; Stopped - display upper case H
 000                         CONSTANT SP_MVMT1, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT2, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT3, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT4, 0F            ; Forward - display upper case F
 000                         CONSTANT SP_MVMT5, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT6, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT7, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT8, 0B            ; Reverse (Backward) - display lower case B
 000                         CONSTANT SP_MVMT9, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMTA, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMTB, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMTC, 19            ; Slow left turn - display upper case L
 000                         CONSTANT SP_MVMTD, 1B            ; Fast left turn - display lower case L
 000                         CONSTANT SP_MVMTE, 1A            ; Slow right turn - display upper case R
 000                         CONSTANT SP_MVMTF, 1C            ; Fast right turn - display lower case R
 000                         ; ==============================
 000                         ; === Storage for old values ===
 000                         ; ==============================
 000                         CONSTANT SP_SEM, 20              ; Semaphore between isr and main loop
 000                         CONSTANT SP_TEMP1, 21            ; Temp storage.  Used by ISR
 000                         CONSTANT SP_TEMP2, 22            ;
 000                         CONSTANT SP_LMDIST, 23           ; Storage for left and right motor distance counters
 000                         CONSTANT SP_RMDIST, 24           ;
 000                         CONSTANT SP_OLDMVMT, 25          ; Old movement value
 000                         CONSTANT SP_OLDHDG, 26           ; Old heading value
 000                         CONSTANT SP_OLDDP, 27            ; Old decimal points
 000                         ; ===============
 000                         ; === main()  ===
 000                         ; ===============
 000                         ADDRESS 000
 000  20027            main: CALL 027[init_btnluptbl]         ; initialize button to MotCtl lookup table
 001  2005E                  CALL 05E[init_mvmttbl]           ; initialize movement to character code lookup table
 002  01100                  LOAD s1, 00                      ; clear the semaphore
 003  2F120                  STORE s1, 20[SP_SEM]             ;
 004  01100                  LOAD s1, 00                      ; turn off all of the decimal points
 005  200F7                  CALL 0F7[SS_wrdpts]              ;
 006  2F127                  STORE s1, 27[SP_OLDDP]           ; and save the value
 007  28001                  ENABLE INTERRUPT                 ; get the ball rolling
 008                         ; ==================
 008                         ; === Main  Loop ===
 008                         ; ==================
 008                         ; while(1) {  // main loop is an infinite loop
 008  0B620         main_L0: FETCH s6, 20[SP_SEM]             ;  while (SP_SEMA == 0)  {}   // loop until isr updates rojobot registers
 009  1D600                  COMPARE s6, 00                   ;
 00A  32008                  JUMP Z, 008[main_L0]             ;
 00B                         ;
 00B  200E8                  CALL 0E8[DEB_rdsw]               ;  s0 = switches
 00C  0D001                  TEST s0, 01[MSK_SW0]             ;  if (sw[0] == 0)   // display the Rojobot location
 00D  36010                  JUMP NZ, 010[main_L1]            ; -- Z = 0 says switch is 'on'
 00E  200D0                  CALL 0D0[next_loc]               ;   Dig[3:2] = LocX; Dig[1:0] = LocY
 00F  22012                  JUMP 012[main_L2]                ;
 010                         ;  else {  // display movement and heading
 010  20095         main_L1: CALL 095[next_mvmt]              ;   Dig[3] = next movement
 011  2009D                  CALL 09D[next_hdg]               ;   Dig[2:0] = next heading
 012                         ;  }
 012  2001A         main_L2: CALL 01A[wr_alldigits]           ;  write all of the digits to the display
 013  001D0                  LOAD s1, sD[Sensor]              ;  update LEDs with new sensor information
 014  200EB                  CALL 0EB[LED_wrleds]             ;               ;
 015  200E1                  CALL 0E1[next_step]              ;  tell rojobot what to do next
 016  0B620                  FETCH s6, 20[SP_SEM]
 017  19601                  SUB s6, 01                       ;  decrement semaphore
 018  2F620                  STORE s6, 20[SP_SEM]             ;
 019  22008                  JUMP 008[main_L0]                ; } // end - main while loop
 01A                         ;**************************************************************************************
 01A                         ; Support functions
 01A                         ;**************************************************************************************
 01A                         ; ===============================================================================
 01A                         ; === wr_alldigits() - Writes all 4 display digits from the global registers  ===
 01A                         ; === Registers used s0,s1,s2, Dig0, Dig1, Dig2, Dig3                         ===
 01A                         ; ===============================================================================
 01A  01200    wr_alldigits: LOAD s2, 00                      ; point at digit 0
 01B  00170                  LOAD s1, s7[Dig0]                ; and write it to display
 01C  200EF                  CALL 0EF[SS_wrdigx]              ;
 01D  01201                  LOAD s2, 01                      ; point at digit 1
 01E  00180                  LOAD s1, s8[Dig1]                ; and write it to display
 01F  200EF                  CALL 0EF[SS_wrdigx]              ;
 020  01202                  LOAD s2, 02                      ; point at digit 2
 021  00190                  LOAD s1, s9[Dig2]                ; and write it to display
 022  200EF                  CALL 0EF[SS_wrdigx]              ;
 023  01203                  LOAD s2, 03                      ; point at digit 3
 024  001A0                  LOAD s1, sA[Dig3]                ; and write it to the display
 025  200EF                  CALL 0EF[SS_wrdigx]              ;
 026  25000                  RETURN 
 027                         ;*******
 027                         ; Functions to convert pushbutton presses to Motor Control input
 027                         ;*******
 027                         ; ===============================================================================
 027                         ; === init_btnluptbl() - initialize button translation lookup table in SP RAM ===
 027                         ; === Registers affected: s0, s1                                              ===
 027                         ; ===============================================================================
 027  01000  init_btnluptbl: LOAD s0, 00[SP_BTNBASE]          ; s0 gets base of button translation lookup table
 028  01100                  LOAD s1, 00[SP_LSRS]             ; s1 gets values for 0x00
 029  2E100                  STORE s1, (s0)                   ; store the entry in the table
 02A  11001                  ADD s0, 01                       ; increment the table index
 02B  01102                  LOAD s1, 02[SP_LORR]             ; s1 gets values for 0x01
 02C  2E100                  STORE s1, (s0)                   ; store the entry in the table
 02D  11001                  ADD s0, 01                       ; increment the table index
 02E  01103                  LOAD s1, 03[SP_LSRF]             ; s1 gets values for 0x02
 02F  2E100                  STORE s1, (s0)                   ; store the entry in the table
 030  11001                  ADD s0, 01                       ; increment the table index
 031  01100                  LOAD s1, 00[SP_LSRFR]            ; s1 gets values for 0x03
 032  2E100                  STORE s1, (s0)                   ; store the entry in the table
 033  11001                  ADD s0, 01                       ; increment the table index
 034  01120                  LOAD s1, 20[SP_LRRS]             ; s1 gets values for 0x04
 035  2E100                  STORE s1, (s0)                   ; store the entry in the table
 036  11001                  ADD s0, 01                       ; increment the table index
 037  01122                  LOAD s1, 22[SP_LRRR]             ; s1 gets values for 0x05
 038  2E100                  STORE s1, (s0)                   ; store the entry in the table
 039  11001                  ADD s0, 01                       ; increment the table index
 03A  01123                  LOAD s1, 23[SP_LRRF]             ; s1 gets values for 0x06
 03B  2E100                  STORE s1, (s0)                   ; store the entry in the table
 03C  11001                  ADD s0, 01                       ; increment the table index
 03D  01120                  LOAD s1, 20[SP_LRRFR]            ; s1 gets values for 0x07
 03E  2E100                  STORE s1, (s0)                   ; store the entry in the table
 03F  11001                  ADD s0, 01                       ; increment the table index
 040  01130                  LOAD s1, 30[SP_LFRS]             ; s1 gets values for 0x08
 041  2E100                  STORE s1, (s0)                   ; store the entry in the table
 042  11001                  ADD s0, 01                       ; increment the table index
 043  01132                  LOAD s1, 32[SP_LFRR]             ; s1 gets values for 0x09
 044  2E100                  STORE s1, (s0)                   ; store the entry in the table
 045  11001                  ADD s0, 01                       ; increment the table index
 046  01133                  LOAD s1, 33[SP_LFRF]             ; s1 gets values for 0x0A
 047  2E100                  STORE s1, (s0)                   ; store the entry in the table
 048  11001                  ADD s0, 01                       ; increment the table index
 049  01130                  LOAD s1, 30[SP_LFRFR]            ; s1 gets values for 0x0B
 04A  2E100                  STORE s1, (s0)                   ; store the entry in the table
 04B  11001                  ADD s0, 01                       ; increment the table index
 04C  01100                  LOAD s1, 00[SP_LFRRS]            ; s1 gets values for 0x0C
 04D  2E100                  STORE s1, (s0)                   ; store the entry in the table
 04E  11001                  ADD s0, 01                       ; increment the table index
 04F  01102                  LOAD s1, 02[SP_LFRRR]            ; s1 gets values for 0x0D
 050  2E100                  STORE s1, (s0)                   ; store the entry in the table
 051  11001                  ADD s0, 01                       ; increment the table index
 052  01103                  LOAD s1, 03[SP_LFRRF]            ; s1 gets values for 0x0E
 053  2E100                  STORE s1, (s0)                   ; store the entry in the table
 054  11001                  ADD s0, 01                       ; increment the table index
 055  01100                  LOAD s1, 00[SP_LFRRFR]           ; s1 gets values for 0x0F
 056  2E100                  STORE s1, (s0)                   ; store the entry in the table
 057  25000                  RETURN                           ; done...at last
 058                         ; =============================================================================
 058                         ; === btn2mot() - Button to MotCtl conversion function                      ===
 058                         ; === Registers affected: s1, s2                                            ===
 058                         ; === s0 contains the button value to convert.                              ===
 058                         ; === Result (Motor Control register value) is returned in s1               ===
 058                         ; === s0 (Button value) is not changed                                      ===
 058                         ; =============================================================================
 058  01200         btn2mot: LOAD s2, 00[SP_BTNBASE]          ; s2 gets base of button conversion table
 059  00100                  LOAD s1, s0                      ; mask out upper nibble of buttons
 05A  0310F                  AND s1, 0F[MSKLOWNIB]            ;
 05B  10210                  ADD s2, s1                       ; s2 = Base + offset into table
 05C  0A120                  FETCH s1, (s2)                   ; and fetch the entry
 05D  25000                  RETURN 
 05E                         ; ===============================================================================
 05E                         ; === init_mvmttbl() - initialize movement translation lookup table in SP RAM ===
 05E                         ; === Registers affected: s0, s1                                              ===
 05E                         ; ===============================================================================
 05E  01010    init_mvmttbl: LOAD s0, 10[SP_MVMTBASE]         ; s0 gets base of movement translation lookup table
 05F  01118                  LOAD s1, 18[SP_MVMT0]            ; s1 gets values for 0x00
 060  2E100                  STORE s1, (s0)                   ; store the entry in the table
 061  11001                  ADD s0, 01                       ; increment the table index
 062  01117                  LOAD s1, 17[SP_MVMT1]            ; s1 gets values for 0x01
 063  2E100                  STORE s1, (s0)                   ; store the entry in the table
 064  11001                  ADD s0, 01                       ; increment the table index
 065  01117                  LOAD s1, 17[SP_MVMT2]            ; s1 gets values for 0x02
 066  2E100                  STORE s1, (s0)                   ; store the entry in the table
 067  11001                  ADD s0, 01                       ; increment the table index
 068  01117                  LOAD s1, 17[SP_MVMT3]            ; s1 gets values for 0x03
 069  2E100                  STORE s1, (s0)                   ; store the entry in the table
 06A  11001                  ADD s0, 01                       ; increment the table index
 06B  0110F                  LOAD s1, 0F[SP_MVMT4]            ; s1 gets values for 0x04
 06C  2E100                  STORE s1, (s0)                   ; store the entry in the table
 06D  11001                  ADD s0, 01                       ; increment the table index
 06E  01117                  LOAD s1, 17[SP_MVMT5]            ; s1 gets values for 0x05
 06F  2E100                  STORE s1, (s0)                   ; store the entry in the table
 070  11001                  ADD s0, 01                       ; increment the table index
 071  01117                  LOAD s1, 17[SP_MVMT6]            ; s1 gets values for 0x06
 072  2E100                  STORE s1, (s0)                   ; store the entry in the table
 073  11001                  ADD s0, 01                       ; increment the table index
 074  01117                  LOAD s1, 17[SP_MVMT7]            ; s1 gets values for 0x07
 075  2E100                  STORE s1, (s0)                   ; store the entry in the table
 076  11001                  ADD s0, 01                       ; increment the table index
 077  0110B                  LOAD s1, 0B[SP_MVMT8]            ; s1 gets values for 0x08
 078  2E100                  STORE s1, (s0)                   ; store the entry in the table
 079  11001                  ADD s0, 01                       ; increment the table index
 07A  01117                  LOAD s1, 17[SP_MVMT9]            ; s1 gets values for 0x09
 07B  2E100                  STORE s1, (s0)                   ; store the entry in the table
 07C  11001                  ADD s0, 01                       ; increment the table index
 07D  01117                  LOAD s1, 17[SP_MVMTA]            ; s1 gets values for 0x0A
 07E  2E100                  STORE s1, (s0)                   ; store the entry in the table
 07F  11001                  ADD s0, 01                       ; increment the table index
 080  01117                  LOAD s1, 17[SP_MVMTB]            ; s1 gets values for 0x0B
 081  2E100                  STORE s1, (s0)                   ; store the entry in the table
 082  11001                  ADD s0, 01                       ; increment the table index
 083  01119                  LOAD s1, 19[SP_MVMTC]            ; s1 gets values for 0x0C
 084  2E100                  STORE s1, (s0)                   ; store the entry in the table
 085  11001                  ADD s0, 01                       ; increment the table index
 086  0111B                  LOAD s1, 1B[SP_MVMTD]            ; s1 gets values for 0x0D
 087  2E100                  STORE s1, (s0)                   ; store the entry in the table
 088  11001                  ADD s0, 01                       ; increment the table index
 089  0111A                  LOAD s1, 1A[SP_MVMTE]            ; s1 gets values for 0x0E
 08A  2E100                  STORE s1, (s0)                   ; store the entry in the table
 08B  11001                  ADD s0, 01                       ; increment the table index
 08C  0111C                  LOAD s1, 1C[SP_MVMTF]            ; s1 gets values for 0x0F
 08D  2E100                  STORE s1, (s0)                   ; store the entry in the table
 08E  25000                  RETURN                           ; done...at last
 08F                         ; =============================================================================
 08F                         ; === mvmt2cc() - movement to character code conversion function            ===
 08F                         ; === Registers affected: s1, s2                                            ===
 08F                         ; === s0 contains the movment value to convert.                             ===
 08F                         ; === Result (character code to display) is returned in s1                  ===
 08F                         ; === s0 (movement) is not changed                                          ===
 08F                         ; =============================================================================
 08F  01210         mvmt2cc: LOAD s2, 10[SP_MVMTBASE]         ; s2 gets base of movment conversion table
 090  00100                  LOAD s1, s0                      ; mask out upper nibble of movment
 091  0310F                  AND s1, 0F[MSKLOWNIB]            ;
 092  10210                  ADD s2, s1                       ; s2 = Base + offset into table
 093  0A120                  FETCH s1, (s2)                   ; and fetch the entry
 094  25000                  RETURN 
 095                         ;#########################################
 095                         ; Modify this function for Project 2 #####
 095                         ;#########################################
 095                         ; ========================================================================
 095                         ; === next_mvmt() - Calculate  digit for motion indicator              ===
 095                         ; === Registers affected: Dig3, s0                                     ===
 095                         ; === Uses Botinf (Bot Info register) to get movement.                 ===
 095                         ; ========================================================================
 095  000C0       next_mvmt: LOAD s0, sC[Botinf]              ; s0[3:0] = Botinf[7:4]
 096  1400E                  SR0 s0                           ;
 097  1400E                  SR0 s0                           ;
 098  1400E                  SR0 s0                           ;
 099  1400E                  SR0 s0                           ;
 09A  2008F                  CALL 08F[mvmt2cc]                ; translate movement to char code
 09B  00A10                  LOAD sA[Dig3], s1                ; and move to digit 3
 09C  25000                  RETURN 
 09D                         ; ==============================================================================
 09D                         ; === next_hdg() - Calculate  digits for heading (compass setting)           ===
 09D                         ; === Registers affected: Dig2, Dig1, Dig0, s0, s1, s2, s3,s4, s5, s6        ===
 09D                         ; === Uses Botinf (Bot Info register) to get orientation.  Calculates digits ===
 09D                         ; === with a case statement based on orientation.                            ===
 09D                         ; ==============================================================================
 09D  000C0        next_hdg: LOAD s0, sC[Botinf]              ; s0[2:0] = Botinf[2:0] = orientation
 09E  03007                  AND s0, 07[MSKORIENT]            ;
 09F                         ; switch(orientation)  {
 09F  1D000      nh_caseORN: COMPARE s0, 00[OR_N]             ; case(OR_N):
 0A0  360A5                  JUMP NZ, 0A5[nh_caseORNE]        ;
 0A1  01400                  LOAD s4, 00                      ;  Dig[2:0] = 000
 0A2  01500                  LOAD s5, 00                      ;
 0A3  01600                  LOAD s6, 00                      ;
 0A4  220CC                  JUMP 0CC[nh_endcase]             ;  break;
 0A5                         ;
 0A5  1D001     nh_caseORNE: COMPARE s0, 01[OR_NE]            ; case (OR_NE):
 0A6  360AB                  JUMP NZ, 0AB[nh_caseORE]         ;
 0A7  01400                  LOAD s4, 00                      ;  Dig[2:0] = 045
 0A8  01504                  LOAD s5, 04                      ;
 0A9  01605                  LOAD s6, 05                      ;
 0AA  220CC                  JUMP 0CC[nh_endcase]             ;  break;
 0AB  1D002      nh_caseORE: COMPARE s0, 02[OR_E]             ; case (OR_E):
 0AC  360B1                  JUMP NZ, 0B1[nh_caseORSE]        ;
 0AD  01400                  LOAD s4, 00                      ;  Dig[2:0] = 090
 0AE  01509                  LOAD s5, 09                      ;
 0AF  01600                  LOAD s6, 00                      ;
 0B0  220CC                  JUMP 0CC[nh_endcase]             ;  break;
 0B1  1D003     nh_caseORSE: COMPARE s0, 03[OR_SE]            ; case (OR_SE):
 0B2  360B7                  JUMP NZ, 0B7[nh_caseORS]         ;
 0B3  01401                  LOAD s4, 01                      ;  Dig[2:0] = 135
 0B4  01503                  LOAD s5, 03                      ;
 0B5  01605                  LOAD s6, 05                      ;
 0B6  220CC                  JUMP 0CC[nh_endcase]             ;  break;
 0B7  1D004      nh_caseORS: COMPARE s0, 04[OR_S]             ; case (OR_S):
 0B8  360BD                  JUMP NZ, 0BD[nh_caseORSW]        ;
 0B9  01401                  LOAD s4, 01                      ;  Dig[2:0] = 180
 0BA  01508                  LOAD s5, 08                      ;
 0BB  01600                  LOAD s6, 00                      ;
 0BC  220CC                  JUMP 0CC[nh_endcase]             ;  break;
 0BD  1D005     nh_caseORSW: COMPARE s0, 05[OR_SW]            ; case (OR_SW):
 0BE  360C3                  JUMP NZ, 0C3[nh_caseORW]         ;
 0BF  01402                  LOAD s4, 02                      ;  Dig[2:0] = 225
 0C0  01502                  LOAD s5, 02                      ;
 0C1  01605                  LOAD s6, 05                      ;
 0C2  220CC                  JUMP 0CC[nh_endcase]             ;  break;
 0C3  1D006      nh_caseORW: COMPARE s0, 06[OR_W]             ; case (OR_W):
 0C4  360C9                  JUMP NZ, 0C9[nh_caseORNW]        ;
 0C5  01402                  LOAD s4, 02                      ;  Dig[2:0] = 270
 0C6  01507                  LOAD s5, 07                      ;
 0C7  01600                  LOAD s6, 00                      ;
 0C8  220CC                  JUMP 0CC[nh_endcase]             ;  break;
 0C9                         ; case (OR_NW):  // only remaining case
 0C9  01403     nh_caseORNW: LOAD s4, 03                      ;  Dig[2:0] = 315
 0CA  01501                  LOAD s5, 01                      ;
 0CB  01605                  LOAD s6, 05                      ;
 0CC                         ; } // end of switch statement
 0CC  00940      nh_endcase: LOAD s9[Dig2], s4                ;
 0CD  00850                  LOAD s8[Dig1], s5                ;
 0CE  00760                  LOAD s7[Dig0], s6                ;
 0CF  25000                  RETURN 
 0D0                         ; ==============================================================================
 0D0                         ; === next_loc() - Calculate digits for Rojobot location                     ===
 0D0                         ; === Registers affected: Dig3, Dig2, Dig1, Dig0, s0                         ===
 0D0                         ; === Uses LocX and LocY to get location.                                    ===
 0D0                         ; ==============================================================================
 0D0  000F0        next_loc: LOAD s0, sF[LocX]                ; Dig[3:2] gets X-coordinate
 0D1  00900                  LOAD s9[Dig2], s0                ; Digit 2 gets lower nibble
 0D2  0390F                  AND s9[Dig2], 0F[MSK_HEXDIGIT]   ;
 0D3  1400E                  SR0 s0                           ; Digit3 gets upper nibble
 0D4  1400E                  SR0 s0                           ;
 0D5  1400E                  SR0 s0                           ;
 0D6  1400E                  SR0 s0                           ;
 0D7  00A00                  LOAD sA[Dig3], s0                ;
 0D8  000E0                  LOAD s0, sE[LocY]                ; Dig[1:0] gets Y-coordinate
 0D9  00700                  LOAD s7[Dig0], s0                ; Digit 0 gets lower nibble
 0DA  0370F                  AND s7[Dig0], 0F[MSK_HEXDIGIT]   ;
 0DB  1400E                  SR0 s0                           ; Digit 1 gets upper nibble
 0DC  1400E                  SR0 s0                           ;
 0DD  1400E                  SR0 s0                           ;
 0DE  1400E                  SR0 s0                           ;
 0DF  00800                  LOAD s8[Dig1], s0                ;
 0E0  25000                  RETURN 
 0E1                         ;#########################################
 0E1                         ; Modify this function for Project 2 #####
 0E1                         ;#########################################
 0E1                         ; ==============================================================================
 0E1                         ; === next_step() - Tells rojobot what to do next                            ===
 0E1                         ; === Registers affected: s0, s1                                             ===
 0E1                         ; === This version reads the pushbuttons, calculates the new Motor Control   ===
 0E1                         ; === register value and then writes MotCtl so Rojobot knows what to do      ===
 0E1                         ; ==============================================================================
 0E1  200E5       next_step: CALL 0E5[DEB_rdbtns]             ; Read the pushbuttons. buttons returned in s0
 0E2  20058                  CALL 058[btn2mot]                ; and calculate new MotCtl - returned in s1
 0E3  2D180                  OUTPUT s1, 80[PA_MOTCTL_IN]      ; tell Rojobot what to do
 0E4  25000                  RETURN 
 0E5                         ;*************************
 0E5                         ; Nexys3 I/O Functions
 0E5                         ;*************************
 0E5                         ;---------------------
 0E5                         ; DEB_rdbtns() - Reads the debounced pushbuttons
 0E5                         ;
 0E5                         ; Returns the 5 pushbuttons. The buttons are returned as follows
 0E5                         ; (assuming the inputs to the I/O interface matches this order)
 0E5                         ; example:
 0E5                         ;    bit  7    6      5        4        3        2        1         0
 0E5                         ;         r    r      r    btn_cntr  btn_left  btn_up  btn_right  btn_down
 0E5                         ;
 0E5                         ; where r = reserved. A value of 1 indicates that the button is pressed.
 0E5                         ; A 0 indicates that the button is not pressed.
 0E5                         ;
 0E5                         ; Registers used s0
 0E5                         ;---------------------
 0E5  09000      DEB_rdbtns: INPUT s0, 00[PA_PBTNS]           ; read the buttons
 0E6  0301F                  AND s0, 1F[MSK_ALLBTNS]          ; mask out unused bits
 0E7  25000                  RETURN                           ; and return
 0E8                         ;---------------------
 0E8                         ; DEB_rdsw() - Reads the debounced switches
 0E8                         ;
 0E8                         ; Returns the four switches in s0. The buttons are returned as follows
 0E8                         ; (assuming the inputs match the order in the pb_rot_7Segemu
 0E8                         ; example:
 0E8                         ;    bit  7    6    5   4    3    2    1    0
 0E8                         ;        sw7  sw6  sw5 sw4  sw3  sw2  sw1  sw0
 0E8                         ;
 0E8                         ; where r = reserved, sw7 is the leftmost switch and sw0 is the rightmost
 0E8                         ; switch. A value of 1 indicates that the switch is on (up).  A 0 indicates that
 0E8                         ; the switch is off (down).
 0E8                         ;
 0E8                         ; Registers used s0
 0E8                         ;---------------------
 0E8  09001        DEB_rdsw: INPUT s0, 01[PA_SLSWTCH]         ; read the slide switches
 0E9  030FF                  AND s0, FF[MSK_ALLSW]            ; mask out unused bits
 0EA  25000                  RETURN                           ; and return
 0EB                         ;---------------------
 0EB                         ; LED_wrleds() - Write the LEDs
 0EB                         ;
 0EB                         ; Writes the pattern in s1 to the LEDs
 0EB                         ;
 0EB                         ; Registers used s0, s1
 0EB                         ;---------------------
 0EB  00010      LED_wrleds: LOAD s0, s1                      ; Copy LEDs to s0 to preserve them
 0EC  030FF                  AND s0, FF[MSK_LEDS]             ; mask out unused bits
 0ED  2D010                  OUTPUT s0, 10[PA_LEDS]           ; and write pattern to the LEDs
 0EE  25000                  RETURN                           ; and return
 0EF                         ;---------------------
 0EF                         ; SS_wrdigx() - Write a digit to the display
 0EF                         ;
 0EF                         ; Writes the value specified in s1 to the digit number
 0EF                         ; in s2.  The digit number must be 0, 1, 2, or 3.  All
 0EF                         ; others numbers will be rejected.
 0EF                         ;
 0EF                         ; Registers used s0, s1, s2, s3
 0EF                         ;---------------------
 0EF  1D204       SS_wrdigx: COMPARE s2, 04                   ; check if the digit number is in range
 0F0  3D000                  RETURN NC                        ; C=0 says s1 >= 04 - out of range so return
 0F1  01010                  LOAD s0, 10[PA_DIG0]             ; calculate port address by starting with port address for digit 0
 0F2  18020                  SUB s0, s2                       ; next subtract out the digit number.  This will give the port address
 0F3                         ; for the selected digit.  Cool - it works because the port
 0F3                         ; addresses for the digits are consecutive starting with digit 3
 0F3  00310                  LOAD s3, s1                      ; Copy the value to s3 so we can leave it unchanged
 0F4  0331F                  AND s3, 1F[MSK_CCODE]            ; mask out unused character code bits
 0F5  2C300                  OUTPUT s3, (s0)                  ; abd write the digit to the display at the port pointed to by s0
 0F6  25000                  RETURN 
 0F7                         ;---------------------
 0F7                         ; SS_wrdpts() - Write the decimal points to the display
 0F7                         ;
 0F7                         ; Writes the decimal points specified in s1 to the display.
 0F7                         ; The decimal point register is formatted as follows:
 0F7                         ;    bit   7    6    5    4     3     2     1     0
 0F7                         ;          r    r    r    r    dp3   dp2   dp1   dp0
 0F7                         ;
 0F7                         ; where r = reserved, dp3 (leftmost), dp2, dp1 dp0 (rightmost) = 1
 0F7                         ; lights the decimal point. A 0 in the position turns off the decimal point
 0F7                         ;
 0F7                         ; Registers used s0,s1
 0F7                         ;---------------------
 0F7  00010       SS_wrdpts: LOAD s0, s1                      ; Copy the decimal points to s0 to leave s1 unchanged
 0F8  0300F                  AND s0, 0F[MSK_DECPTS]           ; and mask out the unused bits
 0F9  2D020                  OUTPUT s0, 20[PA_DP]             ; write the decimal points to the display
 0FA  25000                  RETURN 
 0FB                         ;---------------------
 0FB                         ; SS_wrall() - Write all of the digits and decimal points to the display
 0FB                         ;
 0FB                         ; Writes all of the digits and decimal points to the display.  The values of the
 0FB                         ; digits and decimal point will be taken from 5 consecutive locations in the
 0FB                         ; PicoBlaze scratchpad RAM starting with the byte pointed to by s1.
 0FB                         ; Digits are arranged as follows:
 0FB                         ; (s1) Dig0
 0FB                         ; (s1+1) Dig1
 0FB                         ; (s1+2) Dig2
 0FB                         ; (s1+3) Dig3
 0FB                         ; (s1+4) Decimal points {dp3, dp2, dp1, dp0}
 0FB                         ;
 0FB                         ; Registers used s0, s1, s2, s3, s4
 0FB                         ;---------------------
 0FB  00410        SS_wrall: LOAD s4, s1                      ; Copy the SP RAM pointer to s4 to preserve SP RAM offset
 0FC  0A140                  FETCH s1, (s4)                   ; get digit 0. s4 points to it
 0FD  01200                  LOAD s2, 00                      ; tell SS_wrdigx to write digit 0
 0FE  200EF                  CALL 0EF[SS_wrdigx]              ; and write the character
 0FF                         ;
 0FF  11401                  ADD s4, 01                       ; point to digit 1
 100  0A140                  FETCH s1, (s4)                   ; fetch if from the SP RAM
 101  01201                  LOAD s2, 01                      ; tell SS_wrdigx to write digit 1
 102  200EF                  CALL 0EF[SS_wrdigx]              ; and write the character
 103                         ;
 103  11401                  ADD s4, 01                       ; point to digit 2
 104  0A140                  FETCH s1, (s4)                   ; fetch if from the SP RAM
 105  01202                  LOAD s2, 02                      ; tell SS_wrdigx to write digit 2
 106  200EF                  CALL 0EF[SS_wrdigx]              ; and write the character
 107                         ;
 107  11401                  ADD s4, 01                       ; point to digit 3
 108  0A140                  FETCH s1, (s4)                   ; fetch if from the SP RAM
 109  01203                  LOAD s2, 03                      ; tell SS_wrdigx to write digit 3
 10A  200EF                  CALL 0EF[SS_wrdigx]              ; and write the character
 10B                         ;
 10B  11401                  ADD s4, 01                       ; point to decimal points
 10C  0A140                  FETCH s1, (s4)                   ; and fetch vector from the SP RAM
 10D  200F7                  CALL 0F7[SS_wrdpts]              ; write the decimal points to display
 10E  25000                  RETURN 
 10F                         ; =========================
 10F                         ; === Interrupt Handler ===
 10F                         ; =========================
 300                         ADDRESS 300
 300  2F621             isr: STORE s6, 21[SP_TEMP1]           ;  save s6, s5
 301  2F522                  STORE s5, 22[SP_TEMP2]           ;
 302  0B620                  FETCH s6, 20[SP_SEM]             ;  fetch the semaphore
 303  0D6FF                  TEST s6, FF                      ; if (SP_SEM == 0) {  // update system register values
 304  3630F                  JUMP NZ, 30F[isr_L0]             ; -- ZF == 0 says semaphore != 0
 305                         ;  // no - get the data from the rojobot emulator
 305  09F02                  INPUT sF[LocX], 02[PA_LOCX]      ;  get Rojobot X-coordinate
 306  09E03                  INPUT sE[LocY], 03[PA_LOCY]      ;  get Rojobot Y-coordinate
 307  09C04                  INPUT sC[Botinf], 04[PA_BOTINFO] ;  get Rojobot Movement and Orientation
 308  09D05                  INPUT sD[Sensor], 05[PA_SENSORS] ;  get Rojobot Sensors
 309  09506                  INPUT s5, 06[PA_LMDIST]          ;  get left and right motor distance counters
 30A  2F523                  STORE s5, 23[SP_LMDIST]          ;  not displayed in this program but let's stash them
 30B  09507                  INPUT s5, 07[PA_RMDIST]          ;  in case we decide we need them in lab 2 or 3
 30C  2F524                  STORE s5, 24[SP_RMDIST]          ;
 30D  11601                  ADD s6, 01                       ;  increment semaphore
 30E  2F620                  STORE s6, 20[SP_SEM]             ; }  // update system register values
 30F  0B627          isr_L0: FETCH s6, 27[SP_OLDDP]           ; toggle  decimal point 0 (rightmost)
 310  07601                  XOR s6, 01                       ;
 311  2D620                  OUTPUT s6, 20[PA_DP]             ; write directly to decpt port to avoid having to save s1
 312  2F627                  STORE s6, 27[SP_OLDDP]           ;
 313  0B521                  FETCH s5, 21[SP_TEMP1]           ;  restore s6, s5
 314  0B622                  FETCH s6, 22[SP_TEMP2]           ;
 315  29001                  RETURNI ENABLE                   ; and return from interrupt
 316                         ; ========================
 316                         ; === Interrupt vector ===
 316                         ; ========================
 3FF                         ADDRESS 3FF
 3FF  22300         intvect: JUMP 300[isr]                    ; jump to interrupt service routine



List of PSM files that have been assembled

C:\ece540_final\rojobot_world\hardware\firmware\proj2demo.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   09'd         
 timestamp_minutes 55'd         
 timestamp_seconds 04'd         
 datestamp_year    12'd         
 datestamp_month   10'd         
 datestamp_day     29'd         
 PA_LEDS           10           proj2demo.psm
 PA_DIG3           02           proj2demo.psm
 PA_DIG2           04           proj2demo.psm
 PA_DIG1           08           proj2demo.psm
 PA_DIG0           10           proj2demo.psm
 PA_DP             20           proj2demo.psm
 PA_RSVD           40           proj2demo.psm
 PA_MOTCTL_IN      80           proj2demo.psm
 PA_PBTNS          00           proj2demo.psm
 PA_SLSWTCH        01           proj2demo.psm
 PA_LOCX           02           proj2demo.psm
 PA_LOCY           03           proj2demo.psm
 PA_BOTINFO        04           proj2demo.psm
 PA_SENSORS        05           proj2demo.psm
 PA_LMDIST         06           proj2demo.psm
 PA_RMDIST         07           proj2demo.psm
 MSK_ALLBTNS       1F           proj2demo.psm
 MSK_PBTNS         0F           proj2demo.psm
 MSK_BTN_CENTER    10           proj2demo.psm
 MSK_BTN_LEFT      08           proj2demo.psm
 MSK_BTN_UP        04           proj2demo.psm
 MSK_BTN_RIGHT     02           proj2demo.psm
 MSK_BTN_DOWN      01           proj2demo.psm
 MSK_ALLSW         FF           proj2demo.psm
 MSK_SW7           80           proj2demo.psm
 MSK_SW6           40           proj2demo.psm
 MSK_SW5           20           proj2demo.psm
 MSK_SW4           10           proj2demo.psm
 MSK_SW3           08           proj2demo.psm
 MSK_SW2           04           proj2demo.psm
 MSK_SW1           02           proj2demo.psm
 MSK_SW0           01           proj2demo.psm
 MSK_LEDS          FF           proj2demo.psm
 MSK_CCODE         1F           proj2demo.psm
 MSK_DECPTS        0F           proj2demo.psm
 MSK_HEXDIGIT      0F           proj2demo.psm
 MSKLOWNIB         0F           proj2demo.psm
 MSKHIGHNIB        F0           proj2demo.psm
 INVLOWNIB         0F           proj2demo.psm
 FALSE             00           proj2demo.psm
 TRUE              01           proj2demo.psm
 NULL              00           proj2demo.psm
 CC_BASE           10           proj2demo.psm
 CC_SEGBASE        10           proj2demo.psm
 CC_SEGA           10           proj2demo.psm
 CC_SEGB           11           proj2demo.psm
 CC_SEGC           12           proj2demo.psm
 CC_SEGD           13           proj2demo.psm
 CC_SEGE           14           proj2demo.psm
 CC_SEGF           15           proj2demo.psm
 CC_SEGG           16           proj2demo.psm
 CC_DOT            17           proj2demo.psm
 CC_UCH            18           proj2demo.psm
 CC_UCL            19           proj2demo.psm
 CC_UCR            1A           proj2demo.psm
 CC_LCL            1B           proj2demo.psm
 CC_LCR            1C           proj2demo.psm
 CC_SPACE1         1D           proj2demo.psm
 CC_SPACE2         1E           proj2demo.psm
 CC_SPACE          1F           proj2demo.psm
 OR_N              00           proj2demo.psm
 OR_NE             01           proj2demo.psm
 OR_E              02           proj2demo.psm
 OR_SE             03           proj2demo.psm
 OR_S              04           proj2demo.psm
 OR_SW             05           proj2demo.psm
 OR_W              06           proj2demo.psm
 OR_NW             07           proj2demo.psm
 MV_STOP           00           proj2demo.psm
 MV_FWD            04           proj2demo.psm
 MV_REV            08           proj2demo.psm
 MV_SLT            0C           proj2demo.psm
 MV_FLT            0D           proj2demo.psm
 MV_SRT            0E           proj2demo.psm
 MV_FRT            0F           proj2demo.psm
 MSKMVMT           0F           proj2demo.psm
 MSKORIENT         07           proj2demo.psm
 SP_BTNBASE        00           proj2demo.psm
 SP_LSRS           00           proj2demo.psm
 SP_LORR           02           proj2demo.psm
 SP_LSRF           03           proj2demo.psm
 SP_LSRFR          00           proj2demo.psm
 SP_LRRS           20           proj2demo.psm
 SP_LRRR           22           proj2demo.psm
 SP_LRRF           23           proj2demo.psm
 SP_LRRFR          20           proj2demo.psm
 SP_LFRS           30           proj2demo.psm
 SP_LFRR           32           proj2demo.psm
 SP_LFRF           33           proj2demo.psm
 SP_LFRFR          30           proj2demo.psm
 SP_LFRRS          00           proj2demo.psm
 SP_LFRRR          02           proj2demo.psm
 SP_LFRRF          03           proj2demo.psm
 SP_LFRRFR         00           proj2demo.psm
 SP_MVMTBASE       10           proj2demo.psm
 SP_MVMT0          18           proj2demo.psm
 SP_MVMT1          17           proj2demo.psm
 SP_MVMT2          17           proj2demo.psm
 SP_MVMT3          17           proj2demo.psm
 SP_MVMT4          0F           proj2demo.psm
 SP_MVMT5          17           proj2demo.psm
 SP_MVMT6          17           proj2demo.psm
 SP_MVMT7          17           proj2demo.psm
 SP_MVMT8          0B           proj2demo.psm
 SP_MVMT9          17           proj2demo.psm
 SP_MVMTA          17           proj2demo.psm
 SP_MVMTB          17           proj2demo.psm
 SP_MVMTC          19           proj2demo.psm
 SP_MVMTD          1B           proj2demo.psm
 SP_MVMTE          1A           proj2demo.psm
 SP_MVMTF          1C           proj2demo.psm
 SP_SEM            20           proj2demo.psm
 SP_TEMP1          21           proj2demo.psm
 SP_TEMP2          22           proj2demo.psm
 SP_LMDIST         23           proj2demo.psm
 SP_RMDIST         24           proj2demo.psm
 SP_OLDMVMT        25           proj2demo.psm
 SP_OLDHDG         26           proj2demo.psm
 SP_OLDDP          27           proj2demo.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.00"        
 datestamp$        "29 Oct 2012"  
 timestamp$        "09:55:04"     



List of line labels

 Label            Addr  Source PSM File

 main             000   proj2demo.psm
 main_L0          008   proj2demo.psm
 main_L1          010   proj2demo.psm
 main_L2          012   proj2demo.psm
 wr_alldigits     01A   proj2demo.psm
 init_btnluptbl   027   proj2demo.psm
 btn2mot          058   proj2demo.psm
 init_mvmttbl     05E   proj2demo.psm
 mvmt2cc          08F   proj2demo.psm
 next_mvmt        095   proj2demo.psm
 next_hdg         09D   proj2demo.psm
 nh_caseORN       09F   proj2demo.psm
 nh_caseORNE      0A5   proj2demo.psm
 nh_caseORE       0AB   proj2demo.psm
 nh_caseORSE      0B1   proj2demo.psm
 nh_caseORS       0B7   proj2demo.psm
 nh_caseORSW      0BD   proj2demo.psm
 nh_caseORW       0C3   proj2demo.psm
 nh_caseORNW      0C9   proj2demo.psm
 nh_endcase       0CC   proj2demo.psm
 next_loc         0D0   proj2demo.psm
 next_step        0E1   proj2demo.psm
 DEB_rdbtns       0E5   proj2demo.psm
 DEB_rdsw         0E8   proj2demo.psm
 LED_wrleds       0EB   proj2demo.psm
 SS_wrdigx        0EF   proj2demo.psm
 SS_wrdpts        0F7   proj2demo.psm
 SS_wrall         0FB   proj2demo.psm
 isr              300   proj2demo.psm
 isr_L0           30F   proj2demo.psm
 intvect          3FF   proj2demo.psm



End of KCPSM6 log file.
