KCPSM6 Assembler log file for program 'C:\ece540_final\CMUCam_Bot\firmware\CMU_if.psm'.
Generated by KCPSM6 version v2.00
Ken Chapman - Xilinx Ltd - 30th April 2012

Assembly datestamp: 05 Dec 2012
Assembly timestamp: 11:24:26

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels


Last occupied address: 269 hex
Nominal program memory size: 1K    address(9:0)


Assembly listing

 Addr Code                         Instruction

 000                               ;///////////////////////////////////////////////////////////////////////////////
 000                               ; FILE:    CMU_if.psm
 000                               ; PROJECT:  ECE 540 Final Project - FPGA-based Color Tracking Robot
 000                               ; AUTHOR:   Eric Krause
 000                               ;
 000                               ; ABOUT:  Picoblaze program to properly initialize CMUCam4 with the desired
 000                               ;           color tracking parameters and recieve tracking data via UART.
 000                               ;           Controls motors and servos to maintain a fixed distance from the
 000                               ;           object being tracked.  Upon power-on, the system takes approximately
 000                               ;           5 seconds, to allow gain/white balance to adjust, and send tracking
 000                               ;           parameters to the CMUCam.   Initialization progress is indicated on
 000                               ;           the 8 LEDs, once all 8 are illuminated, initialization is complete.
 000                               ;
 000                               ;           Servo 0 is the Left/Right servo, and Servo 1 is the up/down servo
 000                               ;///////////////////////////////////////////////////////////////////////////////
 000                               ;
 000                               ; INTERFACE:
 000                               ;   Buttons:
 000                               ;           Center: Resets software and re-initializes CMUCam
 000                               ;
 000                               ;           < all other buttons unused >
 000                               ;
 000                               ;   Switches:
 000                               ;           SW0:  Tracking mode.  SW0 (ON) enables the main functionality of
 000                               ;                 the project.  Robot tracks and maintains distance from/to
 000                               ;                 object with color characteristics listed in constants below.
 000                               ;                 While SW0 = 1, robot will follow a color, and try to find a
 000                               ;                 new target if the target is lost
 000                               ;
 000                               ;           SW1-SW6:  Manual motion.
 000                               ;                 SW1: Rotate Servo 0 Left
 000                               ;                 SW2: Rotate Servo 0 Right
 000                               ;                 SW3: Move Servo 1 Up
 000                               ;                 SW4: Move Servo 1 Down
 000                               ;                 SW5: Rotate Base Left (Counterclockwise)
 000                               ;                 SW6: Rotate Base Right (Clockwise)
 000                               ;
 000                               ;           SW7:  Read rensor port and display result on LEDs.
 000                               ;
 000                               ;   LEDs:
 000                               ;     Initialization:
 000                               ;           During initialization, the LEDs function as a progress meter.
 000                               ;           Once all LEDs are lit, the program is ready to begin, and the
 000                               ;           switches will become responsive.
 000                               ;
 000                               ;     Tracking Mode: (SW0)
 000                               ;           During tracking mode, the actions of the bot are displayed on the
 000                               ;           LEDs as follows:
 000                               ;             0 - Base is rotating left
 000                               ;             1 - Servo 0 is turning left (fast)
 000                               ;             2 - Servo 0 is turning left (fast)
 000                               ;             3 - Servo 1 turning down
 000                               ;             4 - Servo 1 turning up
 000                               ;             5 - Servo 0 is turning left (fast)
 000                               ;             6 - Servo 0 is turning left (fast)
 000                               ;             7 - Base is rotating right
 000                               ;           The encoding is meant so that actions moving the camera left show
 000                               ;           up on the left side of the LEDs (and visa versa with right side) and
 000                               ;           so that faster/more extreme motions are closer to the "outside"
 000                               ;           (LEDs 7 and 0)
 000                               ;
 000                               ;     Sensor Read:  (SW7)
 000                               ;         During sensor read, the sensor port is continuously read and displayed
 000                               ;         on the LEDs.
 000                               ;            LEDs 0, 1:  Left/right edge sensors (ON = edge detected)
 000                               ;            LEDs 5, 4:  Left/right proximity sensors (ON = object detected)
 000                               ;
 000                               ;///////////////////////////////////////////////////////////////////////////////
 000                               ;
 000                               ; ADJUSTABLE CONSTANTS:
 000                               ;   Tracked Color:
 000                               ;
 000                               ;   "The camera board will track all pixels that have a red component that is
 000                               ;   between “red min” and “red max” inclusive, a green component that is between
 000                               ;   “green min” and “green max” inclusive, and a blue component that is between
 000                               ;   “blue min” and “blue max” inclusive... Can be any number between 0 and 255.
 000                               ;     -- From CMUCam4 Command List Manual,
 000                               ;   http://www.cmucam.org/attachments/download/636/CMUcam4-Command-List-102.pdf
 000                               ;
 000                               CONSTANT RED_MIN, CE                         ; ADJUST TO CHANGE TARGET COLOR(S)
 000                               CONSTANT RED_MAX, FF                         ; ADJUST TO CHANGE TARGET COLOR(S)
 000                               CONSTANT GREEN_MIN, 65                       ; ADJUST TO CHANGE TARGET COLOR(S)
 000                               CONSTANT GREEN_MAX, AA                       ; ADJUST TO CHANGE TARGET COLOR(S)
 000                               CONSTANT BLUE_MIN, 50                        ; ADJUST TO CHANGE TARGET COLOR(S)
 000                               CONSTANT BLUE_MAX, 94                        ; ADJUST TO CHANGE TARGET COLOR(S)
 000                               ;
 000                               ;   Thresholds:
 000                               ;
 000                               ;     These constants define when the motors and servos move
 000                               ;       note: "X" and "Y" refer to average X and Y positions of tracked object
 000                               ;
 000                               CONSTANT LM_THRESH, 45'd                     ; Base rotates left if X<LM_THRESH
 000                               CONSTANT LEFT_FAST, 55'd                     ; Servo 0 left fast if LM_THRESH<X<LEFT_FAST
 000                               CONSTANT LEFT_SLOW, 72'd                     ; Servo 0 left slow if LEFT_FAST<X<LEFT_SLOW
 000                               ;         NO MOVEMENT         ; No L/R motion if LEFT_SLOW<X<RIGHT_SLOW
 000                               CONSTANT RIGHT_SLOW, 88'd                    ; Servo 0 right slow if RIGHT_SLOW<X<RIGHT_FAST
 000                               CONSTANT RIGHT_FAST, 105'd                   ; Servo 0 right fast if RIGHT_FAST<X<RM__THRESH
 000                               CONSTANT RM_THRESH, 115'd                    ; Base rotates right if RM_THRESH<X
 000                               CONSTANT UC_THRESH, 32                       ; Servo 1 look up if Y<UC_THRESH
 000                               CONSTANT DC_THRESH, 46                       ; Servo 1 look down if DC_THRESH<Y
 000                               ; Bot will not respond unless confidence and pixel thresholds are exceeded.
 000                               CONSTANT CONF_THRESH, 14                     ;    min confidence
 000                               CONSTANT PIX_THRESH, 01                      ;    min pixels
 000                               ; Bot moves forward if pixels tracked is less than FM_THRESH and reverse if
 000                               ;   pixels tracked is less than BM_TRESH
 000                               CONSTANT FM_THRESH, 03                       ;    forward move thresh
 000                               CONSTANT BM_THRESH, 05                       ;    back move thresh
 000                               ;   Motor Speeds
 000                               CONSTANT SERVO_0_SLOW, 08                    ; slow servo speed
 000                               CONSTANT SERVO_0_FAST, 0C                    ; fast servo speed
 000                               CONSTANT FWD_SP, 19                          ; motor speed (normal forward)
 000                               CONSTANT REV_SP, 17                          ; motor speed (normal reverse)
 000                               CONSTANT BACKUP_SP, 1A                       ; motor speed (when finding edge and reversing)
 000                               CONSTANT LR_SP, 18                           ; motor speed (rotating)
 000                               ;///////////////////////////////////////////////////////////////////////////////
 000                               ; =====================================
 000                               ; === Fixed Constants               ===
 000                               ; =====================================
 000                               CONSTANT BTN_UP, 08                          ; button assignments
 000                               CONSTANT BTN_DOWN, 02                        ; button assignments
 000                               CONSTANT BTN_LEFT, 10                        ; button assignments
 000                               CONSTANT BTN_RIGHT, 04                       ; button assignments
 000                               CONSTANT BTN_CTR, 01                         ; button assignments
 000                               CONSTANT SW_0, 01                            ; SW assignments
 000                               CONSTANT SW_1, 02                            ; SW assignments
 000                               CONSTANT SW_2, 04                            ; SW assignments
 000                               CONSTANT SW_3, 08                            ; SW assignments
 000                               CONSTANT SW_4, 10                            ; SW assignments
 000                               CONSTANT SW_5, 20                            ; SW assignments
 000                               CONSTANT SW_6, 40                            ; SW assignments
 000                               CONSTANT SW_7, 80                            ; SW assignments
 000                               ; ASCII Constants
 000                               CONSTANT HEX_A, 41                           ; ASCII in hex
 000                               CONSTANT HEX_C, 43                           ; ASCII in hex
 000                               CONSTANT HEX_F, 46                           ; ASCII in hex
 000                               CONSTANT HEX_K, 4B                           ; ASCII in hex
 000                               CONSTANT HEX_G, 47                           ; ASCII in hex
 000                               CONSTANT HEX_M, 4D                           ; ASCII in hex
 000                               CONSTANT HEX_N, 4E                           ; ASCII in hex
 000                               CONSTANT HEX_P, 50                           ; ASCII in hex
 000                               CONSTANT HEX_R, 52                           ; ASCII in hex
 000                               CONSTANT HEX_T, 54                           ; ASCII in hex
 000                               CONSTANT HEX_S, 53                           ; ASCII in hex
 000                               CONSTANT HEX_space, 20                       ; ASCII in hex
 000                               CONSTANT HEX_cr, 0D                          ; ASCII in hex
 000                               CONSTANT HEX_0, 30                           ; ASCII in hex
 000                               CONSTANT HEX_1, 31                           ; ASCII in hex
 000                               CONSTANT LED_TURNL, 01                       ; led encodings
 000                               CONSTANT LED_FASTL, 02                       ; led encodings
 000                               CONSTANT LED_SLOWL, 04                       ; led encodings
 000                               CONSTANT LED_UP, 08                          ; led encodings
 000                               CONSTANT LED_DOWN, 10                        ; led encodings
 000                               CONSTANT LED_SLOWR, 20                       ; led encodings
 000                               CONSTANT LED_FASTR, 40                       ; led encodings
 000                               CONSTANT LED_TURNR, 80                       ; led encodings
 000                               CONSTANT NOISE_THRESH, 03                    ; camera noise threshold.  Do not adjust
 000                               CONSTANT EDGE_MASK, 03                       ; mask all but edge
 000                               CONSTANT PROX_MASK, 30                       ; mask all but prox
 000                               ; ==============================================================================
 000                               ; === main() initialize hardware, then enter loop polling of switches.
 000                               ;               manual control (SW1-SW7) is fairly straightforward.
 000                               ;               if SW0 (tracking), 3 functions are used to:
 000                               ;                 (1) get tracking data from the CMUCam (get_tracking_data)
 000                               ;                 (2) process the data, convert it from ascii to binary
 000                               ;                       (process_t_packet)
 000                               ;                 (3) move the bot in response (next_move)
 000                               ; ==============================================================================
 000                               ADDRESS 000
 000  20197                        CALL 197[all_init]
 001                    main_loop: 
 001  09003                        INPUT s0, 03[IPORT_sw]
 002  0D001                        TEST s0, 01
 003  3A015                        JUMP C, 015[track]
 004  0D002                        TEST s0, 02
 005  3A019                        JUMP C, 019[manual_servo_left]
 006  0D004                        TEST s0, 04
 007  3A01E                        JUMP C, 01E[manual_servo_right]
 008  0D008                        TEST s0, 08
 009  3A023                        JUMP C, 023[manual_servo_up]
 00A  0D010                        TEST s0, 10
 00B  3A027                        JUMP C, 027[manual_servo_down]
 00C  0D020                        TEST s0, 20
 00D  3A02B                        JUMP C, 02B[manual_motors_right]
 00E  0D040                        TEST s0, 40
 00F  3A030                        JUMP C, 030[manual_motors_left]
 010  0D080                        TEST s0, 80
 011  3A035                        JUMP C, 035[sensor_read]
 012  010FF                        LOAD s0, FF
 013  2D040                        OUTPUT s0, 40[OPORT_led]
 014                      default: 
 014  22001                        JUMP 001[main_loop]                          ;  if no switches flipped, just continue to poll.
 015                        track: 
 015  200F6                        CALL 0F6[get_tracking_data]
 016  20113                        CALL 113[process_T_packet]
 017  20038                        CALL 038[next_move]
 018  22001                        JUMP 001[main_loop]
 019            manual_servo_left: 
 019  01308                        LOAD s3, 08
 01A  20207                        CALL 207[servo_0_turn_left]
 01B  201F2                        CALL 1F2[delay_20ms]
 01C  20193                        CALL 193[stop_0]
 01D  22001                        JUMP 001[main_loop]
 01E           manual_servo_right: 
 01E  01308                        LOAD s3, 08
 01F  20203                        CALL 203[servo_0_turn_right]
 020  201F2                        CALL 1F2[delay_20ms]
 021  20193                        CALL 193[stop_0]
 022  22001                        JUMP 001[main_loop]
 023              manual_servo_up: 
 023  01301                        LOAD s3, 01
 024  2020D                        CALL 20D[servo_1_turn_up]
 025  201F2                        CALL 1F2[delay_20ms]
 026  22001                        JUMP 001[main_loop]
 027            manual_servo_down: 
 027  01301                        LOAD s3, 01
 028  20216                        CALL 216[servo_1_turn_down]
 029  201F2                        CALL 1F2[delay_20ms]
 02A  22001                        JUMP 001[main_loop]
 02B          manual_motors_right: 
 02B  01317                        LOAD s3, 17
 02C  2008C                        CALL 08C[base_right]
 02D  201F7                        CALL 1F7[delay_1s]
 02E  20229                        CALL 229[motor_init]
 02F  22001                        JUMP 001[main_loop]
 030           manual_motors_left: 
 030  01317                        LOAD s3, 17
 031  20083                        CALL 083[base_left]
 032  201F7                        CALL 1F7[delay_1s]
 033  20229                        CALL 229[motor_init]
 034  22001                        JUMP 001[main_loop]
 035                  sensor_read: 
 035  09105                        INPUT s1, 05[sensor_port]
 036  2D140                        OUTPUT s1, 40[OPORT_led]
 037  22001                        JUMP 001[main_loop]
 038                               ; ==============================================================================
 038                               ; next_move: if confidence and tracked pixels exceed minimum thresholds,
 038                               ;            calls the main motion control function, motor_control.
 038                               ;            otherwise, prevents bot from moving.  After search_count reaches
 038                               ;            zero, the bot will enter "search mode", and try to find new target,
 038                               ;            by resetting Y camera position (to forward) and slowly rotating.
 038                               ; ==============================================================================
 038                    next_move: 
 038                               ; CHECK CONFIDENCE
 038  01014                        LOAD s0, 14[CONF_THRESH]
 039  0B108                        FETCH s1, 08[CONFIDENCE]
 03A  1C100                        COMPARE s1, s0
 03B  3A044                        JUMP C, 044[conf_fail]
 03C                               ; CHECK PIXELS
 03C  0B107                        FETCH s1, 07[PIXELS]
 03D  01001                        LOAD s0, 01[PIX_THRESH]
 03E  1C100                        COMPARE s1, s0
 03F  3A044                        JUMP C, 044[conf_fail]                       ;
 040  01000                        LOAD s0, 00                                  ; reset the search count if something is in frame
 041  2F00A                        STORE s0, 0A[search_count]                   ; reset the search count if something is in frame
 042  20056                        CALL 056[motor_motion]
 043  25000                        RETURN 
 044                    conf_fail: 
 044  20193                        CALL 193[stop_0]
 045  20229                        CALL 229[motor_init]
 046  01000                        LOAD s0, 00
 047  2D040                        OUTPUT s0, 40[OPORT_led]
 048  0B00A                        FETCH s0, 0A[search_count]
 049  1D01E                        COMPARE s0, 1E[30'd]
 04A  3204E                        JUMP Z, 04E[search_mode]
 04B  11001                        ADD s0, 01
 04C  2F00A                        STORE s0, 0A[search_count]
 04D  25000                        RETURN 
 04E                  search_mode: 
 04E  0133C                        LOAD s3, 3C
 04F  2D340                        OUTPUT s3, 40[OPORT_led]
 050  01318                        LOAD s3, 18
 051  2008C                        CALL 08C[base_right]
 052  0133E                        LOAD s3, 3E
 053  2020D                        CALL 20D[servo_1_turn_up]
 054  201F2                        CALL 1F2[delay_20ms]
 055  25000                        RETURN 
 056                               ; ******************************************************************************
 056                               ;  MOTION FUNCTIONS
 056                               ; ******************************************************************************
 056                               ;=============================================================================
 056                 motor_motion: 
 056                               ;             If base needs to rotate, this is done first.
 056                               ;             Once base no longer needs to rotate, the servos are moved so that
 056                               ;             the tracked object is in the center of the frame
 056                               ;             Once the object is centered, the motors move the bot forward or
 056                               ;             back depending on number of tracked pixels
 056                               ;=============================================================================
 056                               ; DOES BASE NEED TO ROTATE?
 056  0102D                        LOAD s0, 2D[LM_THRESH]
 057  0B101                        FETCH s1, 01[MX]
 058  1C100                        COMPARE s1, s0
 059  3A095                        JUMP C, 095[motor_left]                      ; YES, LEFT    (and return)
 05A  01073                        LOAD s0, 73[RM_THRESH]
 05B  1C010                        COMPARE s0, s1
 05C  3A09A                        JUMP C, 09A[motor_right]                     ; YES, RIGHT   (and return)
 05D                               ;  MOTORS DON'T NEED TO TURN, MIGHT NEED TO GO F/R, BUT ONLY
 05D                               ;  IF MX/MY IS IN CENTER OF ALL OTHER THRESHOLDS
 05D  20229                        CALL 229[motor_init]
 05E  2007B                        CALL 07B[y_motion]
 05F  20069                        CALL 069[x_motion]
 060                               ; MX MUST BE IN CENTER OF THRESHOLDS... OK TO DRIVE F/R
 060  0B107                        FETCH s1, 07[PIXELS]
 061  01003                        LOAD s0, 03[FM_THRESH]
 062  1C100                        COMPARE s1, s0
 063  3A0C5                        JUMP C, 0C5[motor_f]                         ; (and return to main)
 064  01005                        LOAD s0, 05[BM_THRESH]
 065  1C010                        COMPARE s0, s1
 066  3A0E1                        JUMP C, 0E1[motor_r]                         ; (and return to main)
 067                         no_z: ; DIDN'T NEED TO GO FORWARD OR BACK... DO NOTHING
 067  20229                        CALL 229[motor_init]
 068  25000                        RETURN 
 069                               ;=============================================================================
 069                     x_motion: 
 069                               ;=============================================================================
 069                               ; TURN SERVO 0 FAST LEFT?
 069  0B101                        FETCH s1, 01[MX]
 06A  01037                        LOAD s0, 37[LEFT_FAST]
 06B  1C100                        COMPARE s1, s0
 06C  3A09F                        JUMP C, 09F[servo_left_fast]
 06D                               ; TURN SERVO 0 SLOW LEFT?
 06D  0B101                        FETCH s1, 01[MX]
 06E  01048                        LOAD s0, 48[LEFT_SLOW]
 06F  1C100                        COMPARE s1, s0
 070  3A0A9                        JUMP C, 0A9[servo_left_slow]
 071                               ; TURN SERVO 0 FAST RIGHT?
 071  0B101                        FETCH s1, 01[MX]
 072  01069                        LOAD s0, 69[RIGHT_FAST]
 073  1C010                        COMPARE s0, s1
 074  3A0A4                        JUMP C, 0A4[servo_right_fast]
 075                               ; TURN SERVO 0 SLOW RIGHT?
 075  0B101                        FETCH s1, 01[MX]
 076  01058                        LOAD s0, 58[RIGHT_SLOW]
 077  1C010                        COMPARE s0, s1
 078  3A0AE                        JUMP C, 0AE[servo_right_slow]
 079                               ; DIDN'T NEED TO TURN LEFT OR RIGHT... STOP AND RETURN
 079                      noturns: 
 079  20193                        CALL 193[stop_0]                             ;
 07A  25000                        RETURN 
 07B                               ;=============================================================================
 07B                     y_motion: 
 07B                               ;=============================================================================
 07B                               ; LOOK UP/DOWN?
 07B  01032                        LOAD s0, 32[UC_THRESH]
 07C  0B102                        FETCH s1, 02[MY]
 07D  1C100                        COMPARE s1, s0                               ; my is less than thresh upper thres
 07E  380B3                        CALL C, 0B3[cam_up]
 07F  01046                        LOAD s0, 46[DC_THRESH]
 080  1C010                        COMPARE s0, s1                               ; lower thresh ls less than my
 081  380BC                        CALL C, 0BC[cam_down]
 082                               ; DIDN'T NEED TO LOOK UP OR DOWN... RETURN
 082  25000                        RETURN 
 083                               ;=============================================================================
 083                               ;-----------movement functions------------------------------------------------
 083                               ;=============================================================================
 083                    base_left: 
 083  20243                        CALL 243[motor_1_forward]
 084  201ED                        CALL 1ED[delay_1ms]
 085  2025D                        CALL 25D[motor_3_forward]
 086  201ED                        CALL 1ED[delay_1ms]
 087  2023D                        CALL 23D[motor_0_reverse]
 088  201ED                        CALL 1ED[delay_1ms]
 089  20256                        CALL 256[motor_2_reverse]
 08A  201ED                        CALL 1ED[delay_1ms]
 08B  25000                        RETURN 
 08C                   base_right: 
 08C  20249                        CALL 249[motor_1_reverse]
 08D  201ED                        CALL 1ED[delay_1ms]
 08E  20263                        CALL 263[motor_3_reverse]
 08F  201ED                        CALL 1ED[delay_1ms]
 090  20239                        CALL 239[motor_0_forward]
 091  201ED                        CALL 1ED[delay_1ms]
 092  20250                        CALL 250[motor_2_forward]
 093  201ED                        CALL 1ED[delay_1ms]
 094  25000                        RETURN 
 095                   motor_left: 
 095  01001                        LOAD s0, 01[LED_TURNL]                       ; leftmost led
 096  2D040                        OUTPUT s0, 40[OPORT_led]
 097  01318                        LOAD s3, 18[LR_SP]
 098  2008C                        CALL 08C[base_right]
 099  25000                        RETURN 
 09A                  motor_right: 
 09A  01080                        LOAD s0, 80[LED_TURNR]                       ; rightmost led
 09B  2D040                        OUTPUT s0, 40[OPORT_led]
 09C  01318                        LOAD s3, 18[LR_SP]
 09D  20083                        CALL 083[base_left]
 09E  25000                        RETURN 
 09F              servo_left_fast: 
 09F  01002                        LOAD s0, 02[LED_FASTL]
 0A0  2D040                        OUTPUT s0, 40[OPORT_led]
 0A1  0130C                        LOAD s3, 0C[SERVO_0_FAST]
 0A2  20207                        CALL 207[servo_0_turn_left]
 0A3  25000                        RETURN 
 0A4             servo_right_fast: 
 0A4  01040                        LOAD s0, 40[LED_FASTR]
 0A5  2D040                        OUTPUT s0, 40[OPORT_led]
 0A6  0130C                        LOAD s3, 0C[SERVO_0_FAST]
 0A7  20203                        CALL 203[servo_0_turn_right]
 0A8  25000                        RETURN 
 0A9              servo_left_slow: 
 0A9  01004                        LOAD s0, 04[LED_SLOWL]
 0AA  2D040                        OUTPUT s0, 40[OPORT_led]
 0AB  01308                        LOAD s3, 08[SERVO_0_SLOW]
 0AC  20207                        CALL 207[servo_0_turn_left]
 0AD  25000                        RETURN 
 0AE             servo_right_slow: 
 0AE  01020                        LOAD s0, 20[LED_SLOWR]
 0AF  2D040                        OUTPUT s0, 40[OPORT_led]
 0B0  01308                        LOAD s3, 08[SERVO_0_SLOW]
 0B1  20203                        CALL 203[servo_0_turn_right]
 0B2  25000                        RETURN 
 0B3                       cam_up: 
 0B3  01308                        LOAD s3, 08[LED_UP]
 0B4  2D340                        OUTPUT s3, 40[OPORT_led]
 0B5  18010                        SUB s0, s1
 0B6  00300                        LOAD s3, s0
 0B7  1430E                        SR0 s3
 0B8  1430E                        SR0 s3
 0B9  20216                        CALL 216[servo_1_turn_down]
 0BA  201F2                        CALL 1F2[delay_20ms]
 0BB  25000                        RETURN 
 0BC                     cam_down: 
 0BC  01310                        LOAD s3, 10[LED_DOWN]
 0BD  2D340                        OUTPUT s3, 40[OPORT_led]
 0BE  18100                        SUB s1, s0
 0BF  00310                        LOAD s3, s1
 0C0  1430E                        SR0 s3
 0C1  1430E                        SR0 s3
 0C2  2020D                        CALL 20D[servo_1_turn_up]
 0C3  201F2                        CALL 1F2[delay_20ms]
 0C4  25000                        RETURN 
 0C5                               ; move forward if not blocked
 0C5                      motor_f: 
 0C5  01300                        LOAD s3, 00
 0C6  20203                        CALL 203[servo_0_turn_right]
 0C7  09005                        INPUT s0, 05[sensor_port]
 0C8  03003                        AND s0, 03[EDGE_MASK]
 0C9  01100                        LOAD s1, 00
 0CA  1C010                        COMPARE s0, s1
 0CB  320D0                        JUMP Z, 0D0[check_prox]
 0CC  09205                        INPUT s2, 05[sensor_port]
 0CD  2D240                        OUTPUT s2, 40[OPORT_led]
 0CE  20229                        CALL 229[motor_init]
 0CF  25000                        RETURN 
 0D0                   check_prox: 
 0D0  09005                        INPUT s0, 05[sensor_port]
 0D1  03030                        AND s0, 30[PROX_MASK]
 0D2  01100                        LOAD s1, 00
 0D3  1C010                        COMPARE s0, s1
 0D4  320DE                        JUMP Z, 0DE[ok_to_fwd]
 0D5  09205                        INPUT s2, 05[sensor_port]
 0D6  2D240                        OUTPUT s2, 40[OPORT_led]
 0D7  0131A                        LOAD s3, 1A[BACKUP_SP]
 0D8  200ED                        CALL 0ED[base_reverse]
 0D9  201F7                        CALL 1F7[delay_1s]
 0DA  201F7                        CALL 1F7[delay_1s]
 0DB  201F7                        CALL 1F7[delay_1s]
 0DC  20229                        CALL 229[motor_init]
 0DD  25000                        RETURN 
 0DE                    ok_to_fwd: 
 0DE  01319                        LOAD s3, 19[FWD_SP]
 0DF  200E4                        CALL 0E4[base_forward]
 0E0  25000                        RETURN 
 0E1                               ; move in reverse
 0E1                      motor_r: 
 0E1  01317                        LOAD s3, 17[REV_SP]
 0E2  200ED                        CALL 0ED[base_reverse]
 0E3  25000                        RETURN 
 0E4                               ; drive motors forward
 0E4                 base_forward: 
 0E4  20243                        CALL 243[motor_1_forward]
 0E5  201ED                        CALL 1ED[delay_1ms]
 0E6  2025D                        CALL 25D[motor_3_forward]
 0E7  201ED                        CALL 1ED[delay_1ms]
 0E8  20239                        CALL 239[motor_0_forward]
 0E9  201ED                        CALL 1ED[delay_1ms]
 0EA  20250                        CALL 250[motor_2_forward]
 0EB  201ED                        CALL 1ED[delay_1ms]
 0EC  25000                        RETURN 
 0ED                               ; drive motors reverse
 0ED                 base_reverse: 
 0ED  20249                        CALL 249[motor_1_reverse]
 0EE  201ED                        CALL 1ED[delay_1ms]
 0EF  20263                        CALL 263[motor_3_reverse]
 0F0  201ED                        CALL 1ED[delay_1ms]
 0F1  2023D                        CALL 23D[motor_0_reverse]
 0F2  201ED                        CALL 1ED[delay_1ms]
 0F3  20256                        CALL 256[motor_2_reverse]
 0F4  201ED                        CALL 1ED[delay_1ms]
 0F5  25000                        RETURN 
 0F6                               ; ******************************************************************************
 0F6                               ;  ADDITIONAL SUPPORT FUNCTIONS
 0F6                               ; ******************************************************************************
 0F6                               ; ==============================================================================
 0F6                               ; get_tracking_data: sends the command below to CMUCam (without quotes)
 0F6                               ; "TC <RED_MIN> <RED_MAX> <GREEN_MIN> <GREEN_MAX> <BLUE_MIN> <BLUE_MAX>\r"
 0F6                               ; which activates the track color command on the board.
 0F6                               ;
 0F6                               ;   uses send_cmd (sends s1, s2 over uart), send_sp (sends space),
 0F6                               ;   bin_to_ascii (converts binary value in s0 to 3-digit ascii number in
 0F6                               ;   s1, s2, s3), send_num(sends s1, s2, s3 over uart), and send_cr (sends
 0F6                               ;   carriage return)
 0F6                               ; ==============================================================================
 0F6            get_tracking_data: 
 0F6  01154                        LOAD s1, 54[HEX_T]
 0F7  01243                        LOAD s2, 43[HEX_C]
 0F8  20188                        CALL 188[send_cmd]
 0F9  20190                        CALL 190[send_sp]
 0FA  010CE                        LOAD s0, CE[RED_MIN]
 0FB  2015F                        CALL 15F[bin_to_ascii]
 0FC  20175                        CALL 175[send_num]
 0FD  20190                        CALL 190[send_sp]
 0FE  010FF                        LOAD s0, FF[RED_MAX]
 0FF  2015F                        CALL 15F[bin_to_ascii]
 100  20175                        CALL 175[send_num]
 101  20190                        CALL 190[send_sp]
 102  01065                        LOAD s0, 65[GREEN_MIN]
 103  2015F                        CALL 15F[bin_to_ascii]
 104  20175                        CALL 175[send_num]
 105  20190                        CALL 190[send_sp]
 106  010AA                        LOAD s0, AA[GREEN_MAX]
 107  2015F                        CALL 15F[bin_to_ascii]
 108  20175                        CALL 175[send_num]
 109  20190                        CALL 190[send_sp]
 10A  01050                        LOAD s0, 50[BLUE_MIN]
 10B  2015F                        CALL 15F[bin_to_ascii]
 10C  20175                        CALL 175[send_num]
 10D  20190                        CALL 190[send_sp]
 10E  01094                        LOAD s0, 94[BLUE_MAX]
 10F  2015F                        CALL 15F[bin_to_ascii]
 110  20175                        CALL 175[send_num]
 111  2018D                        CALL 18D[send_cr]
 112  25000                        RETURN 
 113                               ; ==============================================================================
 113                               ; process_T_packet:
 113                               ; Recieves all data passed in T packet, primarily using the read_3_dig function,
 113                               ; which recieves a 1 to 3-digit ascii number and converts it to binary.
 113                               ; The following data is stored in respective registers:
 113                               ;
 113                               ;   mx – The average of all X position coordinate values of all tracked pixels
 113                               ;   my – The average of all Y position coordinate values of all tracked pixels
 113                               ;   x1 – The X position value of the top left most corner of tracked pixels
 113                               ;   y1 – The Y position value of the top left most corner of tracked pixels
 113                               ;   x2 – The X position value of the bottom right most corner of tracked pixels
 113                               ;   y2 – The Y position value of the bottom right most corner of tracked pixels
 113                               ;   pixels – The percentage of the number of pixels tracked in the color
 113                               ;     tracking window, ranging from 0 to 255.
 113                               ;   confidence – The percentage of the number of pixels tracked in the bounding
 113                               ;     box ranging from 0 to 255.
 113                               ;
 113                               ;   -- CMUCam 4 Command Manual
 113                               ;
 113                               ; Currently, x1/y1 and x2/y2 are not used.
 113                               ; ==============================================================================
 113             process_T_packet: 
 113  2014E                        CALL 14E[get_char]                           ;
 114  1D520                        COMPARE s5, 20[HEX_space]                    ; advance to next loop upon finding T
 115  32117                        JUMP Z, 117[got_sp]                          ; continue on recieving space (" ")
 116  22113                        JUMP 113[process_T_packet]
 117                       got_sp: 
 117  20151                        CALL 151[read_3dig]                          ;
 118  2F001                        STORE s0, 01[MX]                             ;
 119  20151                        CALL 151[read_3dig]                          ;
 11A  2F002                        STORE s0, 02[MY]                             ;
 11B  20151                        CALL 151[read_3dig]                          ;
 11C  2F003                        STORE s0, 03[X1]                             ;
 11D  20151                        CALL 151[read_3dig]                          ;
 11E  2F004                        STORE s0, 04[Y1]                             ;
 11F  20151                        CALL 151[read_3dig]                          ;
 120  2F005                        STORE s0, 05[X2]                             ;
 121  20151                        CALL 151[read_3dig]                          ;
 122  2F006                        STORE s0, 06[Y2]                             ;
 123  20151                        CALL 151[read_3dig]                          ;
 124  2F007                        STORE s0, 07[PIXELS]                         ;
 125  20151                        CALL 151[read_3dig]                          ;
 126  2F008                        STORE s0, 08[CONFIDENCE]                     ;
 127  201BD                        CALL 1BD[reset_UART_macros]                  ; flush the uart fifos, we are done.
 128  25000                        RETURN 
 129                               ;-------------------------------------------------------------------------------
 129                               ; long_delay: delays a long time
 129                               ;-------------------------------------------------------------------------------
 129                   long_delay: 
 129  201F7                        CALL 1F7[delay_1s]
 12A  201F7                        CALL 1F7[delay_1s]
 12B  201F7                        CALL 1F7[delay_1s]
 12C  201F7                        CALL 1F7[delay_1s]
 12D  201F7                        CALL 1F7[delay_1s]
 12E  25000                        RETURN 
 12F                               ;-------------------------------------------------------------------------------
 12F                               ; reset_CMU: resets the CMUcam and waits to recieve "A" in response.  Then uart
 12F                               ; fifos are flushed and subroutine returns to main.
 12F                               ;-------------------------------------------------------------------------------
 12F                    reset_CMU: 
 12F                               ; send "RS\r"
 12F  01152                        LOAD s1, 52[HEX_R]
 130  01253                        LOAD s2, 53[HEX_S]
 131  20188                        CALL 188[send_cmd]
 132  2018D                        CALL 18D[send_cr]
 133                      rc_next: 
 133  2014E                        CALL 14E[get_char]
 134  1D541                        COMPARE s5, 41[HEX_A]                        ; was the character "A" ?
 135  36133                        JUMP NZ, 133[rc_next]                        ; no: get the next char
 136  201BD                        CALL 1BD[reset_UART_macros]
 137  25000                        RETURN 
 138                               ;-------------------------------------------------------------------------------
 138                               ; init_enable_polling: enables polling mode on CMU cam by sending "PM \r" and
 138                               ; waiting to recieve "A" in response.  Then uart fifos are flushed
 138                               ;-------------------------------------------------------------------------------
 138               init_enable_pm: 
 138  01150                        LOAD s1, 50[HEX_P]                           ;
 139  0124D                        LOAD s2, 4D[HEX_M]                           ;
 13A  20188                        CALL 188[send_cmd]                           ; send "PM "
 13B  20190                        CALL 190[send_sp]                            ; send " "
 13C  01531                        LOAD s5, 31[HEX_1]                           ; send "1"
 13D  201C0                        CALL 1C0[UART_TX]                            ;
 13E  2018D                        CALL 18D[send_cr]                            ; send "\r"
 13F                     epm_next: 
 13F  2014E                        CALL 14E[get_char]
 140  1D541                        COMPARE s5, 41[HEX_A]                        ; was the character "A" ?
 141  3613F                        JUMP NZ, 13F[epm_next]                       ; no: get the next char
 142  201BD                        CALL 1BD[reset_UART_macros]
 143  25000                        RETURN 
 144                               ;-------------------------------------------------------------------------------
 144                               ; init_enable_nf: enables noise filter on CMU cam by sending:
 144                               ; "NF <NOISE_THRESH>\r" and waiting to recieve "A" in response.
 144                               ; Then uart fifos are flushed
 144                               ;-------------------------------------------------------------------------------
 144               init_enable_nf: 
 144  0114E                        LOAD s1, 4E[HEX_N]
 145  01246                        LOAD s2, 46[HEX_F]
 146  20188                        CALL 188[send_cmd]
 147  20190                        CALL 190[send_sp]
 148  01003                        LOAD s0, 03[NOISE_THRESH]
 149  2015F                        CALL 15F[bin_to_ascii]
 14A  20175                        CALL 175[send_num]
 14B  2018D                        CALL 18D[send_cr]
 14C  201BD                        CALL 1BD[reset_UART_macros]
 14D  25000                        RETURN 
 14E                               ;-------------------------------------------------------------------------------
 14E                               ; get_char
 14E                               ; recieve character from uart, place in s5.  Cannot fail (never times out)
 14E                               ;-------------------------------------------------------------------------------
 14E                     get_char: 
 14E  201C5                        CALL 1C5[UART_RX]
 14F  3214E                        JUMP Z, 14E[get_char]                        ;
 150  25000                        RETURN 
 151                               ;-------------------------------------------------------------------------------
 151                               ; read_3dig: output in s0.  reads 1-3 digit ascii number, converts to bin.
 151                               ;-------------------------------------------------------------------------------
 151                    read_3dig: 
 151  2014E                        CALL 14E[get_char]
 152  19530                        SUB s5, 30
 153  00250                        LOAD s2, s5                                  ; sum is s2
 154                        rloop: 
 154  2014E                        CALL 14E[get_char]
 155  1D520                        COMPARE s5, 20[HEX_space]
 156  3215D                        JUMP Z, 15D[r3return]
 157  1D50D                        COMPARE s5, 0D[HEX_cr]
 158  3215D                        JUMP Z, 15D[r3return]
 159  2016E                        CALL 16E[mult_10]                            ; input s2, output s2 -- multiply stored value by 10
 15A  19530                        SUB s5, 30                                   ; convert read char to bin
 15B  10250                        ADD s2, s5                                   ; add to (sum*10)
 15C  22154                        JUMP 154[rloop]
 15D                     r3return: 
 15D  00020                        LOAD s0, s2
 15E  25000                        RETURN 
 15F                               ;-------------------------------------------------------------------------------
 15F                               ; bin_to_ascii
 15F                               ; convert a binary number in s0 to a 3-digit ascii in s1, s2, s3
 15F                               ;-------------------------------------------------------------------------------
 15F                 bin_to_ascii: 
 15F  01130                        LOAD s1, 30[HEX_0]
 160  01230                        LOAD s2, 30[HEX_0]
 161  01330                        LOAD s3, 30[HEX_0]
 162                     over_100: ; if until number is less than 100, subtract 100 and store
 162                               ; number of subtractions in s1
 162  1D064                        COMPARE s0, 64
 163  3A167                        JUMP C, 167[less_than_100]
 164  19064                        SUB s0, 64
 165  11101                        ADD s1, 01
 166  22162                        JUMP 162[over_100]
 167                less_than_100: ; if until number is less than 10, subtract 10 and store
 167                               ; number of subtractions in s2
 167  1D00A                        COMPARE s0, 0A
 168  3A16C                        JUMP C, 16C[less_than_10]
 169  1900A                        SUB s0, 0A
 16A  11201                        ADD s2, 01
 16B  22167                        JUMP 167[less_than_100]
 16C                 less_than_10: ; whatever is left at this point can be copied to s3 (ones)
 16C  10300                        ADD s3, s0
 16D  25000                        RETURN 
 16E                               ;-------------------------------------------------------------------------------
 16E                               ; mult_10; input s2, output s2
 16E                               ;   X<<1 + X<<3 = 10X
 16E                               ;-------------------------------------------------------------------------------
 16E                      mult_10: 
 16E  00120                        LOAD s1, s2
 16F  14106                        SL0 s1
 170  14106                        SL0 s1
 171  14106                        SL0 s1
 172  14206                        SL0 s2
 173  10210                        ADD s2, s1
 174  25000                        RETURN 
 175                               ;-------------------------------------------------------------------------------
 175                               ; send_num: input: 3 digit decimal number in ascii
 175                               ;     s1 = hundreds
 175                               ;     s2 = tens
 175                               ;     s3 = ones
 175                               ; converts the numbers to ascii and sends them all out over uart
 175                               ; avoids sending unnecessary zeros (e.g., sending 005 instead of 5)
 175                               ;-------------------------------------------------------------------------------
 175                     send_num: 
 175  00510                        LOAD s5, s1
 176  1D530                        COMPARE s5, 30[HEX_0]
 177  3217E                        JUMP Z, 17E[hundreds_zero]
 178  201C0                        CALL 1C0[UART_TX]
 179  00520                        LOAD s5, s2
 17A  201C0                        CALL 1C0[UART_TX]
 17B  00530                        LOAD s5, s3
 17C  201C0                        CALL 1C0[UART_TX]
 17D  25000                        RETURN 
 17E                hundreds_zero: 
 17E  00520                        LOAD s5, s2
 17F  1D530                        COMPARE s5, 30[HEX_0]
 180  32185                        JUMP Z, 185[tens_zero]
 181  201C0                        CALL 1C0[UART_TX]
 182  00530                        LOAD s5, s3
 183  201C0                        CALL 1C0[UART_TX]
 184  25000                        RETURN 
 185                    tens_zero: 
 185  00530                        LOAD s5, s3
 186  201C0                        CALL 1C0[UART_TX]
 187  25000                        RETURN 
 188                               ;-------------------------------------------------------------------------------
 188                               ; send_cmd: sends command "<s1><s2>"
 188                               ; input:  s1 = first letter of cmd
 188                               ;       s2 = second letter of cmd
 188                               ;-------------------------------------------------------------------------------
 188                     send_cmd: 
 188  00510                        LOAD s5, s1                                  ;
 189  201C0                        CALL 1C0[UART_TX]                            ;
 18A  00520                        LOAD s5, s2                                  ;
 18B  201C0                        CALL 1C0[UART_TX]                            ;
 18C  25000                        RETURN 
 18D                               ;-------------------------------------------------------------------------------
 18D                               ; send_cr: sends carriage return
 18D                               ;-------------------------------------------------------------------------------
 18D                      send_cr: 
 18D  0150D                        LOAD s5, 0D[HEX_cr]
 18E  201C0                        CALL 1C0[UART_TX]
 18F  25000                        RETURN 
 190                               ;-------------------------------------------------------------------------------
 190                               ; send_sp sends space
 190                               ;-------------------------------------------------------------------------------
 190                      send_sp: 
 190  01520                        LOAD s5, 20[HEX_space]
 191  201C0                        CALL 1C0[UART_TX]
 192  25000                        RETURN 
 193                               ;-------------------------------------------------------------------------------
 193                               ; stops servo 0
 193                               ;-------------------------------------------------------------------------------
 193                       stop_0: 
 193  01300                        LOAD s3, 00
 194  20207                        CALL 207[servo_0_turn_left]
 195  201F2                        CALL 1F2[delay_20ms]
 196  25000                        RETURN 
 197                               ;-------------------------------------------------------------------------------
 197                               ; all initialization
 197                               ; - initializes motors and servos
 197                               ; - flushes UART fifo buffers
 197                               ; - resets CMUCam
 197                               ; - lowers servo 1 to point forward (starts pointing up)
 197                               ; - delays ~5 seconds to allow auto gain/white balance to run on CMUCam
 197                               ; - enables polling mode on CMUCam (only responds to requests, doesn't stream)
 197                               ; - enables noise filtering on CMUCam using NOISE_THRESH constant
 197                               ; -
 197                               ;-------------------------------------------------------------------------------
 197                     all_init: 
 197  2D040                        OUTPUT s0, 40[OPORT_led]                     ;
 198  20229                        CALL 229[motor_init]                         ; init hw
 199  201FC                        CALL 1FC[servo_init]                         ; init hw
 19A  201BD                        CALL 1BD[reset_UART_macros]                  ; flush fifos
 19B  201F7                        CALL 1F7[delay_1s]
 19C  01001                        LOAD s0, 01                                  ; time required for CMUCam power cycle
 19D  2D040                        OUTPUT s0, 40[OPORT_led]                     ; time required for CMUCam power cycle
 19E  2012F                        CALL 12F[reset_CMU]                          ; time required for CMUCam power cycle
 19F  20129                        CALL 129[long_delay]                         ; time required for CMUCam power cycle
 1A0  20129                        CALL 129[long_delay]                         ; time required for CMUCam power cycle
 1A1  01003                        LOAD s0, 03                                  ; time required for CMUCam power cycle
 1A2  2D040                        OUTPUT s0, 40[OPORT_led]                     ; time required for CMUCam power cycle
 1A3  20129                        CALL 129[long_delay]                         ; time required for CMUCam power cycle
 1A4  0133E                        LOAD s3, 3E                                  ; turn servo 1 down
 1A5  2020D                        CALL 20D[servo_1_turn_up]                    ; turn servo 1 down
 1A6  20129                        CALL 129[long_delay]                         ; turn servo 1 down
 1A7  01300                        LOAD s3, 00                                  ; turn servo 1 down
 1A8  2020D                        CALL 20D[servo_1_turn_up]                    ; turn servo 1 down
 1A9  0100F                        LOAD s0, 0F                                  ; allow 5 seconds for auto gain / white balance
 1AA  2D040                        OUTPUT s0, 40[OPORT_led]                     ; allow 5 seconds for auto gain / white balance
 1AB  20129                        CALL 129[long_delay]                         ; allow 5 seconds for auto gain / white balance
 1AC  20129                        CALL 129[long_delay]                         ; allow 5 seconds for auto gain / white balance
 1AD  0101F                        LOAD s0, 1F                                  ; allow 5 seconds for auto gain / white balance
 1AE  2D040                        OUTPUT s0, 40[OPORT_led]                     ; allow 5 seconds for auto gain / white balance
 1AF  20129                        CALL 129[long_delay]                         ; allow 5 seconds for auto gain / white balance
 1B0  20129                        CALL 129[long_delay]                         ; allow 5 seconds for auto gain / white balance
 1B1  0103F                        LOAD s0, 3F                                  ; allow 5 seconds for auto gain / white balance
 1B2  2D040                        OUTPUT s0, 40[OPORT_led]                     ; allow 5 seconds for auto gain / white balance
 1B3  20129                        CALL 129[long_delay]                         ; allow 5 seconds for auto gain / white balance
 1B4  20129                        CALL 129[long_delay]                         ; allow 5 seconds for auto gain / white balance
 1B5  0107F                        LOAD s0, 7F
 1B6  2D040                        OUTPUT s0, 40[OPORT_led]
 1B7  20138                        CALL 138[init_enable_pm]                     ; enable polling mode
 1B8  20144                        CALL 144[init_enable_nf]                     ; enable noise filter
 1B9  010FF                        LOAD s0, FF                                  ; indicate completion of init
 1BA  2D040                        OUTPUT s0, 40[OPORT_led]                     ; indicate completion of init
 1BB  201F7                        CALL 1F7[delay_1s]                           ; indicate completion of init
 1BC  25000                        RETURN 
 1BD                               ; ******************************************************************************
 1BD                               ;  INCLUDES
 1BD                               ; ******************************************************************************
 1BD                               INCLUDE "C:\ece540_final\CMUCam_Bot\firmware\interfaces\ports_scratchpads.psm"[".\interfaces\ports_scratchpads.psm"]
 1BD                               ;------------------------------------------------------------------------------------------
 1BD                               ; Assign Scratch Pad Memory Locations
 1BD                               ;------------------------------------------------------------------------------------------
 1BD                               ;
 1BD                               CONSTANT MX, 01
 1BD                               CONSTANT MY, 02
 1BD                               CONSTANT X1, 03
 1BD                               CONSTANT Y1, 04
 1BD                               CONSTANT X2, 05
 1BD                               CONSTANT Y2, 06
 1BD                               CONSTANT PIXELS, 07
 1BD                               CONSTANT CONFIDENCE, 08
 1BD                               CONSTANT TURNCOUNT, 09
 1BD                               CONSTANT search_count, 0A
 1BD                               CONSTANT CURRENT_PHI, 21                     ; store current turn angle (phi) of servo 1, NORMALIZED TO 0-127 RANGE
 1BD                               CONSTANT MOTOR_0_SPEED, 22
 1BD                               CONSTANT MOTOR_1_SPEED, 23
 1BD                               CONSTANT MOTOR_2_SPEED, 24
 1BD                               CONSTANT MOTOR_3_SPEED, 25
 1BD                               ;
 1BD                               ;------------------------------------------------------------------------------------------
 1BD                               ; port declaration
 1BD                               ;------------------------------------------------------------------------------------------
 1BD                               ;
 1BD                               ; SENSOR
 1BD                               CONSTANT sensor_port, 05
 1BD                               ; MOTOR
 1BD                               ;
 1BD                               CONSTANT motor_port, 20                      ; (o) write to motor controller
 1BD                               ;
 1BD                               ; SERVO
 1BD                               ;
 1BD                               CONSTANT servo_port, 10                      ; (o) write to servo controller
 1BD                               ;
 1BD                               ; UART
 1BD                               ;
 1BD                               CONSTANT reset_UART_port, 01                 ; (o) Reset UART buffers (Constant Optimised Port)
 1BD                               CONSTANT UART_status_port, 00                ; (i) Read status
 1BD                               CONSTANT UART_TX6_output_port, 01            ; (o) Write data to UART_TX6
 1BD                               CONSTANT UART_RX6_input_port, 01             ; (i) Read data from UART_RX6
 1BD                               ;
 1BD                               ; LED
 1BD                               ;
 1BD                               CONSTANT OPORT_led, 40                       ; (o) output to on-board leds
 1BD                               CONSTANT IPORT_btn, 04                       ; (i) debounced pushbuttons
 1BD                               CONSTANT IPORT_sw, 03                        ; (i) debounced switches
 1BD                               INCLUDE "C:\ece540_final\CMUCam_Bot\firmware\interfaces\uart_interface_routines.psm"[".\interfaces\uart_interface_routines.psm"]
 1BD                               ;
 1BD                               ;------------------------------------------------------------------------------------------
 1BD                               ; Copyright © 2011-2012, Xilinx, Inc.
 1BD                               ; This file contains confidential and proprietary information of Xilinx, Inc. and is
 1BD                               ; protected under U.S. and international copyright and other intellectual property laws.
 1BD                               ;------------------------------------------------------------------------------------------
 1BD                               ;
 1BD                               ; Ken Chapman - Xilinx Ltd 23rd April 2012
 1BD                               ;
 1BD                               ; Modified by Dung Le
 1BD                               ;
 1BD                               ; 10th Oct 2012 - modified to simple read/echo via uart, move "send" routines from
 1BD                               ; uart_control.psm over here. - Le
 1BD                               ;------------------------------------------------------------------------------------------
 1BD                               ; This file contains routines used to interface with the UART6 macros provided with KCPSM6
 1BD                               ; and was first supplied with a reference design called 'uart6_605' included in the
 1BD                               ; PicoBlaze package. The routines enable characters to be transmitted to and received
 1BD                               ; from the UART macros as well as perform a reset of the FIFO the buffers.
 1BD                               ;
 1BD                               ;     NOTE - This is not a standalone PSM file. The 'uart_control.psm' file supplied with
 1BD                               ;            the reference design stated above includes this file and calls the routines
 1BD                               ;            contained in this file.
 1BD                               ;
 1BD                               ;                INCLUDE "uart_interface_routines.psm"
 1BD                               ;
 1BD                               ;     Hint - The INCLUDE directive was introduced in KCPSM6 Assembler v2.00.
 1BD                               ;
 1BD                               ;
 1BD                               ; Whilst the reference design stated above was presented for the UART macros connected to
 1BD                               ; the USB/UART interface on the Xilinx ML605 Evaluation Kit this file can be ported to
 1BD                               ; any design for any board simply by setting the appropriate values in the CONSTANT
 1BD                               ; directives described below.
 1BD                               ;
 1BD                               ;
 1BD                               ;------------------------------------------------------------------------------------------
 1BD                               ; Hardware Constants
 1BD                               ;------------------------------------------------------------------------------------------
 1BD                               ;
 1BD                               ; The CONSTANT directives below define the input and output ports assigned to the UART
 1BD                               ; macros that implement a 115,200 baud rate communication with the USB/UART on the board.
 1BD                               ; Additional constants identify the allocation of signals to bits within a port.
 1BD                               ;
 1BD                               ;
 1BD                               CONSTANT UART_Tx_data_present, 00000001'b    ; Tx   data_present - bit0
 1BD                               CONSTANT UART_Tx_half_full, 00000010'b       ;         half_full - bit1
 1BD                               CONSTANT UART_Tx_full, 00000100'b            ;              full - bit2
 1BD                               CONSTANT UART_Rx_data_present, 00001000'b    ; Rx   data_present - bit3
 1BD                               CONSTANT UART_Rx_half_full, 00010000'b       ;         half_full - bit4
 1BD                               CONSTANT UART_Rx_full, 00100000'b            ;              full - bit5
 1BD                               ;
 1BD                               ; --------------------------------------------
 1BD                               ;
 1BD                               CONSTANT UART_tx_reset, 00000001'b           ; uart_tx6 reset - bit0
 1BD                               CONSTANT UART_rx_reset, 00000010'b           ; uart_rx6 reset - bit1
 1BD                               CONSTANT UART_reset, 00000011'b              ; reset Tx and Rx
 1BD                               CONSTANT UART_operate, 00000000'b            ; Tx and Rx free to operate
 1BD                               ;
 1BD                               ;
 1BD                               ;
 1BD                               ;------------------------------------------------------------------------------------------
 1BD                               ; Useful data constants
 1BD                               ;------------------------------------------------------------------------------------------
 1BD                               ;
 1BD                               ;
 1BD                               ; ASCII codes
 1BD                               ;
 1BD                               CONSTANT character_NULL, 00                  ;NULL
 1BD                               CONSTANT character_BS, 08                    ;Back Space
 1BD                               CONSTANT character_LF, 0A                    ;line feed
 1BD                               CONSTANT character_CR, 0D                    ;carriage return
 1BD                               CONSTANT character_ESC, 1B                   ;Escape
 1BD                               ;
 1BD                               ;
 1BD                               ;--------------------------------------------------------------------------------------
 1BD                               ; Routine to reset UART Buffers inside 'UART_TX6' and 'UART_RX6'
 1BD                               ;--------------------------------------------------------------------------------------
 1BD                               ;
 1BD                               ; This routine will generate and apply an active High reset pulse to  the FIFO
 1BD                               ; buffers in both the transmitter and receiver macros.
 1BD                               ;
 1BD                               ; Note that the reset signals have been assigned to a constant optimised output port
 1BD                               ; so the 'OUTPUTK' instructions are used and no registers contents are affected.
 1BD                               ;
 1BD                               ;
 1BD  2B031     reset_UART_macros: OUTPUTK 03[UART_reset], 1[reset_UART_port]
 1BE  2B001                        OUTPUTK 00[UART_operate], 1[reset_UART_port]
 1BF  25000                        RETURN 
 1C0                               ;
 1C0                               ;
 1C0                               ;--------------------------------------------------------------------------------------
 1C0                               ; Routine to send one character to the UART Transmitter (UART_TX6)
 1C0                               ;--------------------------------------------------------------------------------------
 1C0                               ;
 1C0                               ; This routine will transmit the character provided in register 's5'.
 1C0                               ;
 1C0                               ; Before the character is output to the 'UART_TX6' macro the status of the FIFO buffer
 1C0                               ; is checked to see if there is space. If the buffer is full then this routine will
 1C0                               ; wait for space to become available (e.g. the time required for a previous character
 1C0                               ; to be transmitted by the UART).
 1C0                               ;
 1C0                               ; Registers used s0 and s5 for the data (which is preserved)
 1C0                               ;
 1C0  09000               UART_TX: INPUT s0, 00[UART_status_port]               ;Check if buffer is full
 1C1  0D004                        TEST s0, 04[UART_Tx_full]
 1C2  361C0                        JUMP NZ, 1C0[UART_TX]                        ;wait if full
 1C3  2D501                        OUTPUT s5, 01[UART_TX6_output_port]
 1C4  25000                        RETURN 
 1C5                               ;
 1C5                               ;
 1C5                               ;--------------------------------------------------------------------------------------
 1C5                               ; Routine to attempt to receive one character from the UART Receiver (UART_RX6)
 1C5                               ;--------------------------------------------------------------------------------------
 1C5                               ;
 1C5                               ; This routine will attempt to receive one character from the 'UART_RX6' macro, and if
 1C5                               ; successful, will return that character in register 's5' and the Zero flag will be
 1C5                               ; reset (Z=0).
 1C5                               ;
 1C5                               ; If there are no characters available to be read from the FIFO buffer within the
 1C5                               ; 'UART_RX6' macro then this routine will timeout after ~2,000 clock cycles (which is
 1C5                               ; 40us at 50MHz) with the Zero flag set (Z=1). This timeout scheme ensures that KCPSM6
 1C5                               ; cannot become stuck in this routine if no characters are received. If you do want
 1C5                               ; KCPSM6 to wait indefinitely for a character to be received then either modify this
 1C5                               ; routine or perform a test of the Zero flag and repeat the call to this routine as
 1C5                               ; shown in this example...
 1C5                               ;
 1C5                               ;          wait_for_UART_RX: CALL UART_RX
 1C5                               ;                            JUMP Z, wait_for_UART_RX
 1C5                               ;
 1C5                               ;
 1C5                               ; Registers used s0 and s5.
 1C5                               ;
 1C5  011A7               UART_RX: LOAD s1, A7[167'd]                           ;Timeout = 167 x (6 instructions x 2 clock cycles)
 1C6  09000            rx_timeout: INPUT s0, 00[UART_status_port]
 1C7  0D008                        TEST s0, 08[UART_Rx_data_present]            ;Z=0 and C=1 when data present
 1C8  361CC                        JUMP NZ, 1CC[read_Rx]
 1C9  19101                        SUB s1, 01[1'd]
 1CA  31000                        RETURN Z                                     ;Timeout returns with Z=1 and C=0
 1CB  221C6                        JUMP 1C6[rx_timeout]
 1CC                               ;
 1CC  09501               read_Rx: INPUT s5, 01[UART_RX6_input_port]            ;read character from buffer
 1CD  25000                        RETURN 
 1CE                               ;
 1CE                               ;
 1CE                               ;------------------------------------------------------------------------------------------
 1CE                               ; Send a message to the UART
 1CE                               ;------------------------------------------------------------------------------------------
 1CE                               ;
 1CE                               ; A message is transmitted to the USB-UART.
 1CE                               ; The start address of the message must be provided in [sB,sA].
 1CE                               ; Terminate the transmission with a NULL character (00 hex).
 1CE                               ;
 1CE                               ;send_message: CALL@ (, )
 1CE                               ;              COMPARE s5, 00                            ;terminate on NUL character
 1CE                               ;              RETURN Z
 1CE                               ;              CALL UART_TX
 1CE                               ;              ADD sA, 1'd
 1CE                               ;              ADDCY sB, 0'd
 1CE                               ;              JUMP send_message
 1CE                               ;
 1CE                               ;
 1CE                               ;------------------------------------------------------------------------------------------
 1CE                               ; Send Carriage Return to UART
 1CE                               ;------------------------------------------------------------------------------------------
 1CE                               ;
 1CE                               ; Registers used s0, s1, s2, and s5.
 1CE                               ;
 1CE  0150D               send_CR: LOAD s5, 0D[character_CR]
 1CF  221C0                        JUMP 1C0[UART_TX]                            ;includes RETURN
 1D0                               ;
 1D0                               ;
 1D0                               ;------------------------------------------------------------------------------------------
 1D0                               ; Send a Space to UART
 1D0                               ;------------------------------------------------------------------------------------------
 1D0                               ;
 1D0                               ; Registers used s0, s1, s2, and s5.
 1D0                               ;
 1D0  01520            send_space: LOAD s5, 20[" "]
 1D1  221C0                        JUMP 1C0[UART_TX]                            ;includes RETURN
 1D2                               ;
 1D2                               ;
 1D2                               ;------------------------------------------------------------------------------------------
 1D2                               ; Clear terminal and home cursor sequences for HyperTerminal (or similar)
 1D2                               ;------------------------------------------------------------------------------------------
 1D2                               ;
 1D2                               ; ANSI Escape Sequences/codes (VT100)
 1D2                               ;
 1D2  0151B          clear_screen: LOAD s5, 1B[character_ESC]                   ;clear terminal sequence
 1D3  201C0                        CALL 1C0[UART_TX]
 1D4  0155B                        LOAD s5, 5B["["]
 1D5  201C0                        CALL 1C0[UART_TX]
 1D6  01532                        LOAD s5, 32["2"]
 1D7  201C0                        CALL 1C0[UART_TX]
 1D8  0154A                        LOAD s5, 4A["J"]
 1D9  201C0                        CALL 1C0[UART_TX]
 1DA  201ED                        CALL 1ED[delay_1ms]                          ;Delay for reliable operation
 1DB  25000                        RETURN 
 1DC                               ;
 1DC  0151B           cursor_home: LOAD s5, 1B[character_ESC]                   ;Send cursor to upper-left of display
 1DD  201C0                        CALL 1C0[UART_TX]
 1DE  0155B                        LOAD s5, 5B["["]
 1DF  201C0                        CALL 1C0[UART_TX]
 1E0  01548                        LOAD s5, 48["H"]
 1E1  201C0                        CALL 1C0[UART_TX]
 1E2  201ED                        CALL 1ED[delay_1ms]                          ;Delay for reliable operation
 1E3  25000                        RETURN 
 1E4                               ;
 1E4                               ;
 1E4                               ;------------------------------------------------------------------------------------------
 1E4                               ; End of 'uart_interface_routines.psm"'
 1E4                               ;------------------------------------------------------------------------------------------
 1E4                               ;
 1E4                               INCLUDE "C:\ece540_final\CMUCam_Bot\firmware\interfaces\delay.psm"[".\interfaces\delay.psm"]
 1E4                               ;------------------------------------------------------------------------------------------
 1E4                               ; Auxiliary method for delay pursoses
 1E4                               ;
 1E4                               ; Originated by Ken Chapman - Xilinx Ltd
 1E4                               ; Modified by Dung Le, 2012
 1E4                               ;**************************************************************************************
 1E4                               ;Software delay routines
 1E4                               ;**************************************************************************************
 1E4                               ;
 1E4                               ;Delay of 1us.
 1E4                               ;
 1E4                               ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
 1E4                               ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
 1E4                               ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
 1E4                               ;
 1E4                               ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 1E4                               ;
 1E4                               ;Registers used s0
 1E4                               ;
 1E4                               CONSTANT delay_1us_constant, 0B
 1E4  0100B             delay_1us: LOAD s0, 0B[delay_1us_constant]
 1E5  19001              wait_1us: SUB s0, 01
 1E6  361E5                        JUMP NZ, 1E5[wait_1us]
 1E7  25000                        RETURN 
 1E8                               ;
 1E8                               ;Delay of 40us.
 1E8                               ;
 1E8                               ;Registers used s0, s1
 1E8                               ;
 1E8  01128            delay_40us: LOAD s1, 28                                  ;40 x 1us = 40us
 1E9  201E4             wait_40us: CALL 1E4[delay_1us]
 1EA  19101                        SUB s1, 01
 1EB  361E9                        JUMP NZ, 1E9[wait_40us]
 1EC  25000                        RETURN 
 1ED                               ;
 1ED                               ;
 1ED                               ;Delay of 1ms.
 1ED                               ;
 1ED                               ;Registers used s0, s1, s2
 1ED                               ;
 1ED  01219             delay_1ms: LOAD s2, 19                                  ;25 x 40us = 1ms
 1EE  201E8              wait_1ms: CALL 1E8[delay_40us]
 1EF  19201                        SUB s2, 01
 1F0  361EE                        JUMP NZ, 1EE[wait_1ms]
 1F1  25000                        RETURN 
 1F2                               ;
 1F2                               ;Delay of 20ms.
 1F2                               ;
 1F2                               ;Delay of 20ms used during initialisation.
 1F2                               ;
 1F2                               ;Registers used s0, s1, s2, s3
 1F2                               ;
 1F2  01314            delay_20ms: LOAD s3, 14                                  ;20 x 1ms = 20ms
 1F3  201ED             wait_20ms: CALL 1ED[delay_1ms]
 1F4  19301                        SUB s3, 01
 1F5  361F3                        JUMP NZ, 1F3[wait_20ms]
 1F6  25000                        RETURN 
 1F7                               ;
 1F7                               ;Delay of approximately 1 second.
 1F7                               ;
 1F7                               ;Registers used s0, s1, s2, s3, s4
 1F7                               ;
 1F7  01414              delay_1s: LOAD s4, 14                                  ;50 x 20ms = 1000ms
 1F8  201F2               wait_1s: CALL 1F2[delay_20ms]
 1F9  19401                        SUB s4, 01
 1FA  361F8                        JUMP NZ, 1F8[wait_1s]
 1FB  25000                        RETURN 
 1FC                               ;
 1FC                               INCLUDE "C:\ece540_final\CMUCam_Bot\firmware\interfaces\servo_interface_routines.psm"[".\interfaces\servo_interface_routines.psm"]
 1FC                               ;------------------------------------------------------------------------------------------
 1FC                               ; Pan/tilt servo driver
 1FC                               ; Copyright by Dung Le, 2012
 1FC                               ;------------------------------------------------------------------------------------------
 1FC                               ; Definition: simple routines for controlling servo. This driver incoporates with
 1FC                               ; the hdl design in servo_controller.v. Currently support both continuous (full) rotation
 1FC                               ; servo and normal (0-180 degree) servo.
 1FC                               ;
 1FC                               ; NOTE:
 1FC                               ; - Servo control register definition:
 1FC                               ;   + bit [5-0]: speed, 64 steps
 1FC                               ;   + bit 6: direction bit
 1FC                               ;   + bit 7: servo select bit
 1FC                               ; - The output pulse width from servo_controller unit are 0.5 - 2.5 ms for normal
 1FC                               ;   servo, 1 - 2 ms for full rotation servo. PWM period is 16ms (fpga board run at 10MHZ)
 1FC                               ;
 1FC                               ;------------------------------------------------------------------------------------------
 1FC                               ; CONSTANTS
 1FC                               ;------------------------------------------------------------------------------------------
 1FC                               ;
 1FC                               CONSTANT MAX_SPEED, 3F
 1FC                               CONSTANT MAX_PHI, 7F
 1FC                               CONSTANT CENTER_POSITION, 3F
 1FC                               CONSTANT DIRECTION_BIT, 40
 1FC                               CONSTANT SERVO_SELECT_BIT, 80
 1FC                               ;
 1FC                               ;------------------------------------------------------------------------------------------
 1FC                               ; SERVO ROUTINES
 1FC                               ;------------------------------------------------------------------------------------------
 1FC                               ;
 1FC                               ; USAGE:
 1FC                               ; - set up desired speed on s3
 1FC                               ; - call the appropriate routine for your need
 1FC                               ;
 1FC                               ; Registers used: s1,s2,s3
 1FC                               ;   s3 - input (speed), 6-bit (max 64 steps)
 1FC                               ;   s1,s2 - output regs
 1FC                               ;------------------------------------------------------------------------------------------
 1FC                   servo_init: 
 1FC  0133F                        LOAD s3, 3F[CENTER_POSITION]                 ; center position - 90 deg
 1FD  2F321                        STORE s3, 21[CURRENT_PHI]
 1FE  01300                        LOAD s3, 00
 1FF  01200                        LOAD s2, 00
 200  01100                        LOAD s1, 00
 201  20203                        CALL 203[servo_0_turn_right]
 202  25000                        RETURN 
 203                               ;------------------------------------------------------------------------------------------
 203                               ; servo 0 is continuous rotation servo
 203                               ;------------------------------------------------------------------------------------------
 203           servo_0_turn_right: 
 203  1D33F                        COMPARE s3, 3F[MAX_SPEED]
 204  3D000                        RETURN NC                                    ; return if speed greater than upper bound
 205  2D310                        OUTPUT s3, 10[servo_port]
 206  25000                        RETURN 
 207                               ;
 207                               ;
 207                               ;
 207            servo_0_turn_left: 
 207  1D33F                        COMPARE s3, 3F[MAX_SPEED]
 208  3D000                        RETURN NC                                    ; return if speed greater than upper bound
 209  00130                        LOAD s1, s3
 20A  11140                        ADD s1, 40
 20B  2D110                        OUTPUT s1, 10[servo_port]
 20C  25000                        RETURN 
 20D                               ;------------------------------------------------------------------------------------------
 20D                               ; servo 1 is normal 0-180 rotation servo
 20D                               ;------------------------------------------------------------------------------------------
 20D              servo_1_turn_up: 
 20D  1D33F                        COMPARE s3, 3F[MAX_SPEED]
 20E  3D000                        RETURN NC                                    ; return if turn angle >= upper bound
 20F  0B121                        FETCH s1, 21[CURRENT_PHI]                    ; current phi from memory
 210  10130                        ADD s1, s3                                   ; current_phi = current_phi + turn angle
 211  1D17F                        COMPARE s1, 7F[MAX_PHI]                      ; check if current_phi < MAX_PHI
 212  3A21D                        JUMP C, 21D[calculate_turn_angle]            ; yes, no need to fixup, jump
 213  0117F                        LOAD s1, 7F[MAX_PHI]                         ; else set current phi to MAX_PHI - 1
 214  19101                        SUB s1, 01
 215  2221D                        JUMP 21D[calculate_turn_angle]
 216                               ;
 216                               ;
 216                               ;
 216            servo_1_turn_down: 
 216  1D33F                        COMPARE s3, 3F[MAX_SPEED]
 217  3D000                        RETURN NC                                    ; return if turn angle >= upper bound
 218  0B121                        FETCH s1, 21[CURRENT_PHI]                    ; current phi from memory
 219  18130                        SUB s1, s3                                   ; current_phi = current_phi - turn angle
 21A  3E21D                        JUMP NC, 21D[calculate_turn_angle]           ; jump if current_phi >= 0
 21B  01100                        LOAD s1, 00                                  ; else set current phi to 0
 21C  2221D                        JUMP 21D[calculate_turn_angle]
 21D                               ;------------------------------------------------------------------------------------------
 21D                               ; This section below is used by both above routines
 21D                               ;------------------------------------------------------------------------------------------
 21D         calculate_turn_angle: 
 21D  2F121                        STORE s1, 21[CURRENT_PHI]                    ; save current_phi for later use
 21E                               ;
 21E                               ; now determine the bits that will be send out
 21E                               ;
 21E  1D13F                        COMPARE s1, 3F[CENTER_POSITION]              ; check if current_phi < CENTER_POSITION
 21F  3E224                        JUMP NC, 224[servo_1_label2]                 ; no, jump
 220  0123F                        LOAD s2, 3F[CENTER_POSITION]                 ;
 221  18210                        SUB s2, s1                                   ; output phi = CENTER_POSITION - currentphi
 222  00120                        LOAD s1, s2
 223  22226                        JUMP 226[servo_1_label3]
 224               servo_1_label2: 
 224  1913F                        SUB s1, 3F[CENTER_POSITION]                  ; else, output phi = current phi - CENTER_POSITION
 225  11140                        ADD s1, 40[DIRECTION_BIT]                    ; when current phi > CENTER_POSITION, must set DIRECTION BIT
 226               servo_1_label3: 
 226  11180                        ADD s1, 80[SERVO_SELECT_BIT]                 ; when use servo 1, must set SELECTION BIT
 227  2D110                        OUTPUT s1, 10[servo_port]                    ; write to controller
 228  25000                        RETURN 
 229                               INCLUDE "C:\ece540_final\CMUCam_Bot\firmware\interfaces\motor_interface_routines.psm"[".\interfaces\motor_interface_routines.psm"]
 229                               ;------------------------------------------------------------------------------------------
 229                               ; Pan/tilt servo driver
 229                               ; Copyright by Dung Le, 2012
 229                               ;------------------------------------------------------------------------------------------
 229                               ; Definition: simple routines for interface with standard motor controller board.
 229                               ; This driver incoporates with the hdl design in motor_controller.v
 229                               ;
 229                               ;
 229                               ; NOTE:
 229                               ; - Control register definition:
 229                               ;   + bit [4-0]: speed, 32 steps
 229                               ;   + bit 5: direction bit
 229                               ;   + bit [7:6]: motor select bit
 229                               ; - The PWM period is 0.8ms (fpga board run at 100MHZ)
 229                               ;
 229                               ;------------------------------------------------------------------------------------------
 229                               ; CONSTANTS
 229                               ;------------------------------------------------------------------------------------------
 229                               ;
 229                               CONSTANT MOTOR_MAX_SPEED, 1F
 229                               ;
 229                               ;
 229                               ;------------------------------------------------------------------------------------------
 229                               ; MOTOR ROUTINES
 229                               ;------------------------------------------------------------------------------------------
 229                               ;
 229                               ; USAGE:
 229                               ; - set up desired speed on s3
 229                               ; - call the appropriate routine for your need
 229                               ;
 229                               ;
 229                               ; Registers used: s1,s2,s3
 229                               ;   s3 - input (speed), 6-bit (max 64 steps)
 229                               ;   s1,s2 - output regs
 229                               ;------------------------------------------------------------------------------------------
 229                   motor_init: 
 229  01300                        LOAD s3, 00
 22A  20239                        CALL 239[motor_0_forward]
 22B  201ED                        CALL 1ED[delay_1ms]
 22C  01300                        LOAD s3, 00
 22D  20243                        CALL 243[motor_1_forward]
 22E  201ED                        CALL 1ED[delay_1ms]
 22F  01300                        LOAD s3, 00
 230  20250                        CALL 250[motor_2_forward]
 231  201ED                        CALL 1ED[delay_1ms]
 232  01300                        LOAD s3, 00
 233  2025D                        CALL 25D[motor_3_forward]
 234  2F322                        STORE s3, 22[MOTOR_0_SPEED]
 235  2F323                        STORE s3, 23[MOTOR_1_SPEED]
 236  2F324                        STORE s3, 24[MOTOR_2_SPEED]
 237  2F325                        STORE s3, 25[MOTOR_3_SPEED]
 238  25000                        RETURN 
 239                               ;------------------------------------------------------------------------------------------
 239                               ; servo 0 is continuous rotation servo
 239                               ;------------------------------------------------------------------------------------------
 239              motor_0_forward: 
 239  1D31F                        COMPARE s3, 1F[MOTOR_MAX_SPEED]
 23A  3D000                        RETURN NC                                    ; return if speed greater than upper bound
 23B  2D320                        OUTPUT s3, 20[motor_port]
 23C  25000                        RETURN 
 23D                               ;
 23D                               ;
 23D                               ;
 23D              motor_0_reverse: 
 23D  1D31F                        COMPARE s3, 1F[MOTOR_MAX_SPEED]
 23E  3D000                        RETURN NC                                    ; return if speed greater than upper bound
 23F  00130                        LOAD s1, s3
 240  11120                        ADD s1, 20                                   ; set reverse bit
 241  2D120                        OUTPUT s1, 20[motor_port]
 242  25000                        RETURN 
 243              motor_1_forward: 
 243  1D31F                        COMPARE s3, 1F[MOTOR_MAX_SPEED]
 244  3D000                        RETURN NC                                    ; return if speed greater than upper bound
 245  00130                        LOAD s1, s3
 246  11140                        ADD s1, 40                                   ; select motor 1
 247  2D120                        OUTPUT s1, 20[motor_port]
 248  25000                        RETURN 
 249                               ;
 249                               ;
 249                               ;
 249              motor_1_reverse: 
 249  1D31F                        COMPARE s3, 1F[MOTOR_MAX_SPEED]
 24A  3D000                        RETURN NC                                    ; return if speed greater than upper bound
 24B  00130                        LOAD s1, s3
 24C  11120                        ADD s1, 20                                   ; set reverse bit
 24D  11140                        ADD s1, 40                                   ; select motor 1
 24E  2D120                        OUTPUT s1, 20[motor_port]
 24F  25000                        RETURN 
 250              motor_2_forward: 
 250  1D31F                        COMPARE s3, 1F[MOTOR_MAX_SPEED]
 251  3D000                        RETURN NC                                    ; return if speed greater than upper bound
 252  00130                        LOAD s1, s3
 253  11180                        ADD s1, 80                                   ; select motor 2
 254  2D120                        OUTPUT s1, 20[motor_port]
 255  25000                        RETURN 
 256                               ;
 256                               ;
 256                               ;
 256              motor_2_reverse: 
 256  1D31F                        COMPARE s3, 1F[MOTOR_MAX_SPEED]
 257  3D000                        RETURN NC                                    ; return if speed greater than upper bound
 258  00130                        LOAD s1, s3
 259  11180                        ADD s1, 80                                   ; select motor 2
 25A  11120                        ADD s1, 20                                   ; set reverse bit
 25B  2D120                        OUTPUT s1, 20[motor_port]
 25C  25000                        RETURN 
 25D              motor_3_forward: 
 25D  1D31F                        COMPARE s3, 1F[MOTOR_MAX_SPEED]
 25E  3D000                        RETURN NC                                    ; return if speed greater than upper bound
 25F  00130                        LOAD s1, s3
 260  111C0                        ADD s1, C0                                   ; select motor 3
 261  2D120                        OUTPUT s1, 20[motor_port]
 262  25000                        RETURN 
 263                               ;
 263                               ;
 263                               ;
 263              motor_3_reverse: 
 263  1D31F                        COMPARE s3, 1F[MOTOR_MAX_SPEED]
 264  3D000                        RETURN NC                                    ; return if speed greater than upper bound
 265  00130                        LOAD s1, s3
 266  11120                        ADD s1, 20                                   ; set reverse bit
 267  111C0                        ADD s1, C0                                   ; select motor
 268  2D120                        OUTPUT s1, 20[motor_port]
 269  25000                        RETURN 



List of PSM files that have been assembled

C:\ece540_final\CMUCam_Bot\firmware\CMU_if.psm
C:\ece540_final\CMUCam_Bot\firmware\interfaces\ports_scratchpads.psm
C:\ece540_final\CMUCam_Bot\firmware\interfaces\uart_interface_routines.psm
C:\ece540_final\CMUCam_Bot\firmware\interfaces\delay.psm
C:\ece540_final\CMUCam_Bot\firmware\interfaces\servo_interface_routines.psm
C:\ece540_final\CMUCam_Bot\firmware\interfaces\motor_interface_routines.psm



List of defined constants

 CONSTANT name        Value        Source PSM File

 timestamp_hours      11'd         
 timestamp_minutes    24'd         
 timestamp_seconds    26'd         
 datestamp_year       12'd         
 datestamp_month      12'd         
 datestamp_day        05'd         
 RED_MIN              CE           CMU_if.psm
 RED_MAX              FF           CMU_if.psm
 GREEN_MIN            65           CMU_if.psm
 GREEN_MAX            AA           CMU_if.psm
 BLUE_MIN             50           CMU_if.psm
 BLUE_MAX             94           CMU_if.psm
 LM_THRESH            45'd         CMU_if.psm
 LEFT_FAST            55'd         CMU_if.psm
 LEFT_SLOW            72'd         CMU_if.psm
 RIGHT_SLOW           88'd         CMU_if.psm
 RIGHT_FAST           105'd        CMU_if.psm
 RM_THRESH            115'd        CMU_if.psm
 UC_THRESH            32           CMU_if.psm
 DC_THRESH            46           CMU_if.psm
 CONF_THRESH          14           CMU_if.psm
 PIX_THRESH           01           CMU_if.psm
 FM_THRESH            03           CMU_if.psm
 BM_THRESH            05           CMU_if.psm
 SERVO_0_SLOW         08           CMU_if.psm
 SERVO_0_FAST         0C           CMU_if.psm
 FWD_SP               19           CMU_if.psm
 REV_SP               17           CMU_if.psm
 BACKUP_SP            1A           CMU_if.psm
 LR_SP                18           CMU_if.psm
 BTN_UP               08           CMU_if.psm
 BTN_DOWN             02           CMU_if.psm
 BTN_LEFT             10           CMU_if.psm
 BTN_RIGHT            04           CMU_if.psm
 BTN_CTR              01           CMU_if.psm
 SW_0                 01           CMU_if.psm
 SW_1                 02           CMU_if.psm
 SW_2                 04           CMU_if.psm
 SW_3                 08           CMU_if.psm
 SW_4                 10           CMU_if.psm
 SW_5                 20           CMU_if.psm
 SW_6                 40           CMU_if.psm
 SW_7                 80           CMU_if.psm
 HEX_A                41           CMU_if.psm
 HEX_C                43           CMU_if.psm
 HEX_F                46           CMU_if.psm
 HEX_K                4B           CMU_if.psm
 HEX_G                47           CMU_if.psm
 HEX_M                4D           CMU_if.psm
 HEX_N                4E           CMU_if.psm
 HEX_P                50           CMU_if.psm
 HEX_R                52           CMU_if.psm
 HEX_T                54           CMU_if.psm
 HEX_S                53           CMU_if.psm
 HEX_space            20           CMU_if.psm
 HEX_cr               0D           CMU_if.psm
 HEX_0                30           CMU_if.psm
 HEX_1                31           CMU_if.psm
 LED_TURNL            01           CMU_if.psm
 LED_FASTL            02           CMU_if.psm
 LED_SLOWL            04           CMU_if.psm
 LED_UP               08           CMU_if.psm
 LED_DOWN             10           CMU_if.psm
 LED_SLOWR            20           CMU_if.psm
 LED_FASTR            40           CMU_if.psm
 LED_TURNR            80           CMU_if.psm
 NOISE_THRESH         03           CMU_if.psm
 EDGE_MASK            03           CMU_if.psm
 PROX_MASK            30           CMU_if.psm
 MX                   01           ports_scratchpads.psm
 MY                   02           ports_scratchpads.psm
 X1                   03           ports_scratchpads.psm
 Y1                   04           ports_scratchpads.psm
 X2                   05           ports_scratchpads.psm
 Y2                   06           ports_scratchpads.psm
 PIXELS               07           ports_scratchpads.psm
 CONFIDENCE           08           ports_scratchpads.psm
 TURNCOUNT            09           ports_scratchpads.psm
 search_count         0A           ports_scratchpads.psm
 CURRENT_PHI          21           ports_scratchpads.psm
 MOTOR_0_SPEED        22           ports_scratchpads.psm
 MOTOR_1_SPEED        23           ports_scratchpads.psm
 MOTOR_2_SPEED        24           ports_scratchpads.psm
 MOTOR_3_SPEED        25           ports_scratchpads.psm
 sensor_port          05           ports_scratchpads.psm
 motor_port           20           ports_scratchpads.psm
 servo_port           10           ports_scratchpads.psm
 reset_UART_port      01           ports_scratchpads.psm
 UART_status_port     00           ports_scratchpads.psm
 UART_TX6_output_port 01           ports_scratchpads.psm
 UART_RX6_input_port  01           ports_scratchpads.psm
 OPORT_led            40           ports_scratchpads.psm
 IPORT_btn            04           ports_scratchpads.psm
 IPORT_sw             03           ports_scratchpads.psm
 UART_Tx_data_present 00000001'b   uart_interface_routines.psm
 UART_Tx_half_full    00000010'b   uart_interface_routines.psm
 UART_Tx_full         00000100'b   uart_interface_routines.psm
 UART_Rx_data_present 00001000'b   uart_interface_routines.psm
 UART_Rx_half_full    00010000'b   uart_interface_routines.psm
 UART_Rx_full         00100000'b   uart_interface_routines.psm
 UART_tx_reset        00000001'b   uart_interface_routines.psm
 UART_rx_reset        00000010'b   uart_interface_routines.psm
 UART_reset           00000011'b   uart_interface_routines.psm
 UART_operate         00000000'b   uart_interface_routines.psm
 character_NULL       00           uart_interface_routines.psm
 character_BS         08           uart_interface_routines.psm
 character_LF         0A           uart_interface_routines.psm
 character_CR         0D           uart_interface_routines.psm
 character_ESC        1B           uart_interface_routines.psm
 delay_1us_constant   0B           delay.psm
 MAX_SPEED            3F           servo_interface_routines.psm
 MAX_PHI              7F           servo_interface_routines.psm
 CENTER_POSITION      3F           servo_interface_routines.psm
 DIRECTION_BIT        40           servo_interface_routines.psm
 SERVO_SELECT_BIT     80           servo_interface_routines.psm
 MOTOR_MAX_SPEED      1F           motor_interface_routines.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.00"        
 datestamp$        "05 Dec 2012"  
 timestamp$        "11:24:26"     



List of line labels

 Label                  Addr  Source PSM File

 main_loop              001   CMU_if.psm
 default                014   CMU_if.psm
 track                  015   CMU_if.psm
 manual_servo_left      019   CMU_if.psm
 manual_servo_right     01E   CMU_if.psm
 manual_servo_up        023   CMU_if.psm
 manual_servo_down      027   CMU_if.psm
 manual_motors_right    02B   CMU_if.psm
 manual_motors_left     030   CMU_if.psm
 sensor_read            035   CMU_if.psm
 next_move              038   CMU_if.psm
 conf_fail              044   CMU_if.psm
 search_mode            04E   CMU_if.psm
 motor_motion           056   CMU_if.psm
 no_z                   067   CMU_if.psm
 x_motion               069   CMU_if.psm
 noturns                079   CMU_if.psm
 y_motion               07B   CMU_if.psm
 base_left              083   CMU_if.psm
 base_right             08C   CMU_if.psm
 motor_left             095   CMU_if.psm
 motor_right            09A   CMU_if.psm
 servo_left_fast        09F   CMU_if.psm
 servo_right_fast       0A4   CMU_if.psm
 servo_left_slow        0A9   CMU_if.psm
 servo_right_slow       0AE   CMU_if.psm
 cam_up                 0B3   CMU_if.psm
 cam_down               0BC   CMU_if.psm
 motor_f                0C5   CMU_if.psm
 check_prox             0D0   CMU_if.psm
 ok_to_fwd              0DE   CMU_if.psm
 motor_r                0E1   CMU_if.psm
 base_forward           0E4   CMU_if.psm
 base_reverse           0ED   CMU_if.psm
 get_tracking_data      0F6   CMU_if.psm
 process_T_packet       113   CMU_if.psm
 got_sp                 117   CMU_if.psm
 long_delay             129   CMU_if.psm
 reset_CMU              12F   CMU_if.psm
 rc_next                133   CMU_if.psm
 init_enable_pm         138   CMU_if.psm
 epm_next               13F   CMU_if.psm
 init_enable_nf         144   CMU_if.psm
 get_char               14E   CMU_if.psm
 read_3dig              151   CMU_if.psm
 rloop                  154   CMU_if.psm
 r3return               15D   CMU_if.psm
 bin_to_ascii           15F   CMU_if.psm
 over_100               162   CMU_if.psm
 less_than_100          167   CMU_if.psm
 less_than_10           16C   CMU_if.psm
 mult_10                16E   CMU_if.psm
 send_num               175   CMU_if.psm
 hundreds_zero          17E   CMU_if.psm
 tens_zero              185   CMU_if.psm
 send_cmd               188   CMU_if.psm
 send_cr                18D   CMU_if.psm
 send_sp                190   CMU_if.psm
 stop_0                 193   CMU_if.psm
 all_init               197   CMU_if.psm
 reset_UART_macros      1BD   uart_interface_routines.psm
 UART_TX                1C0   uart_interface_routines.psm
 UART_RX                1C5   uart_interface_routines.psm
 rx_timeout             1C6   uart_interface_routines.psm
 read_Rx                1CC   uart_interface_routines.psm
 send_CR                1CE   uart_interface_routines.psm
 send_space             1D0   uart_interface_routines.psm
 clear_screen           1D2   uart_interface_routines.psm
 cursor_home            1DC   uart_interface_routines.psm
 delay_1us              1E4   delay.psm
 wait_1us               1E5   delay.psm
 delay_40us             1E8   delay.psm
 wait_40us              1E9   delay.psm
 delay_1ms              1ED   delay.psm
 wait_1ms               1EE   delay.psm
 delay_20ms             1F2   delay.psm
 wait_20ms              1F3   delay.psm
 delay_1s               1F7   delay.psm
 wait_1s                1F8   delay.psm
 servo_init             1FC   servo_interface_routines.psm
 servo_0_turn_right     203   servo_interface_routines.psm
 servo_0_turn_left      207   servo_interface_routines.psm
 servo_1_turn_up        20D   servo_interface_routines.psm
 servo_1_turn_down      216   servo_interface_routines.psm
 calculate_turn_angle   21D   servo_interface_routines.psm
 servo_1_label2         224   servo_interface_routines.psm
 servo_1_label3         226   servo_interface_routines.psm
 motor_init             229   motor_interface_routines.psm
 motor_0_forward        239   motor_interface_routines.psm
 motor_0_reverse        23D   motor_interface_routines.psm
 motor_1_forward        243   motor_interface_routines.psm
 motor_1_reverse        249   motor_interface_routines.psm
 motor_2_forward        250   motor_interface_routines.psm
 motor_2_reverse        256   motor_interface_routines.psm
 motor_3_forward        25D   motor_interface_routines.psm
 motor_3_reverse        263   motor_interface_routines.psm



End of KCPSM6 log file.
